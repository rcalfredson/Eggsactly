<!doctype html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.2/css/bulma.min.css" />
    <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/main.css') }}">
    <style>
        body {
            display: none
        }
    </style>
    <script src="https://cdn.socket.io/socket.io-3.0.1.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <script src="../static/js/micromodal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.7/paper-full.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ua-parser-js@1.0.2/src/ua-parser.min.js"></script>
    <title>Egg Counting</title>
</head>

<body>
    <div class="hero-head">
        <nav class="navbar">
            <div class="container">
                <div id="navbarMenuHeroA" class="navbar-menu">
                    <div id=userinfo-nav class="navbar-end">
                        {% if current_user.is_authenticated %}
                        <span id=username-text class="navbar-item" {% if is_local %} style="display: none;" {% endif %}>
                            User: {{ name }} {% if google_data %} (Google)
                            {% if google_data.picture %}
                            <img id=google-user-pic src="{{ google_data.picture }}">
                            {% endif %}
                            {% endif %}
                        </span>
                        {% endif %}
                        {% if not current_user.is_authenticated %}
                        <a id=login-link href="#" class="navbar-item">
                            Sign in
                        </a>
                        <a id=signup-link href="#" class="navbar-item">
                            Create account
                        </a>
                        {% endif %}

                        <a id=logout-link onclick=resetUserDropdownIfNeeded() {% if not current_user.is_authenticated %}
                            style="display: none;" {% endif %} href="{{ url_for('auth.logout') }}" class="navbar-item">
                            Sign out
                        </a>
                    </div>
                </div>
            </div>
        </nav>
    </div>
    {% if current_user.is_authenticated %}
    <script type="text/javascript">
        var loggedIn = true;
    </script>
    {% else %}
    <script type="text/javascript">
        var loggedIn = false;
    </script>
    {% endif %}
    <script type="text/javascript">
        const socket = io();
        function rgb(r, g, b) {
            return "rgb(" + r + "," + g + "," + b + ")";
        }
        const colors = {
            lightRed: '#fc2c03',
            red: rgb(155, 18, 29),
            lightGrey: rgb(115, 109, 125),
            grey: '#313036'
        };
        const errorMessages = {
            ImageAnalysisException: 'Image could not be analyzed.',
            CUDAMemoryException: 'Error: system ran out of resources.',
            ImageIgnoredException: "Image marked as ignored.",
            ManualAlignment: "" // text in this case isn't necessary
        }
        const defaultFontSize = 17;
        const gridlineStrokeWidth = 2;
        let sid;
        let input, inputs, inputDiv, inputLbl, inputReset, preview;
        let inputAmender;
        let inputAmenderNormalBckgnd;
        let lastKeyPressed;
        let pathAmendId;
        let filesToUpload = {};
        let chamberTypes = {};
        let annotations = {};
        let orderedImgNames = [];
        let eggLayingRegions = [];
        let rotationAngles = {};
        let unscaledImgBounds = {}
        let idsByOrigImgName = {};
        let lastPongTime;
        let numFailedPings = 0;
        let externalLoginWindow;
        let loginButton;
        let countingState;
        let countingStates = { pre: 'pre', mid: 'mid', post: 'post' };
        let hasErrors;
        let numErrors = 0;
        let hasModifiedTypes;
        let numModifications = 0;
        let chamberRealignmentData = {};
        let currentRealignmentMarkers = { lines: {}, circles: {} }
        let shapeBeingDragged = false;
        let editMode;
        let tempMaskGridlines;
        let overlappingExistingGridline;
        let gridXYMarkers;
        const lockGridlinesText = 'Lock gridlines and select regions';
        const lockMaskText = 'Lock mask and reposition image';
        const freehandMaskEditInstructions = 'Drag to draw bounding boxes around egg-laying regions (hold shift to pan)';
        const gridMaskEditInstructions = 'Click to add gridlines; shift + click to delete. Lock gridlines to select egg-laying regions.';
        const maskEditInstructions = {
            grid: gridMaskEditInstructions,
            freehand: freehandMaskEditInstructions
        };
        const imageTransformInstructions = 'Transforming image: drag to pan; shift + drag to rotate; scroll to zoom';
        let currentMaskBBox;
        let maskNames;
        let lastSelectedMask;
        let maskCopyUpdater;
        let maskNotationButtonGroup;
        let gridlineOrientationButtonGroup;
        const orientations = ['horiz', 'vert'];
        let imageCenterMarker;
        let tempCursor;
        let tempRasterRect;
        let tempCursorCoordText;
        let tempCursorUnderlay;
        let selectDOM;
        let zoom = 1.0;
        let idsWithEdits = new Set();
        let lastScrollTime;
        let lastMouseDownTime;
        let lastCanvasMoveTime;
        let cursorOnCanvas;
        let canvas;
        let canvasLoaded = false;
        let canvasWidth = Math.min(1300, window.innerWidth);
        let canvasHeight = 800;
        const alignmentHelpDialogElements = [
            'frame', 'text', 'button', 'buttonText',
            'exampleImage', 'exampleText', 'hoverSensor'
        ];
        let lastHelpBoxWasMinimized;
        let alignmentHelpDialog = {};
        let logUpdates = [];
        let upperPadding, leftPadding;
        let scalingFactor;
        let zoomScaleImgToMask;
        let combinedScale;
        let pointerDown = false;
        let shiftKeyDown = false;
        let dragStart = false;
        let timeDownUp;
        let origCenter;
        let currentImgIndex = 0;
        let previousImgIndex;
        let backgroundRaster, pic;

        class ButtonGroup {
            constructor(
                parentElement,
                label,
                button1,
                button2,
                onButtonChange
            ) {
                this.parent = parentElement;
                this.label = document.createElement('span');
                this.label.classList.add('label');
                this.label.id = label.id;
                this.label.style.alignContent = 'left;'
                this.label.innerHTML = label.innerHTML;
                this.button1 = document.createElement('button');
                this.button1.id = button1.id;
                this.button1.style.alignContent = 'right';
                this.button1.innerHTML = button1.innerHTML;
                this.button1.group = this;
                this.button1.classList.add(
                    'left-hand-button',
                    'selected'
                );
                this.selected = this.button1.id;
                this.button2 = document.createElement('button');
                this.button2.id = button2.id;
                this.button2.innerHTML = button2.innerHTML;
                this.button2.group = this;
                this.button2.classList.add('right-hand-button');
                this.parent.appendChild(this.label);
                this.parent.appendChild(this.button2);
                this.parent.appendChild(this.button1);
                this.button1.onclick = this.toggleButtons;
                this.button2.onclick = this.toggleButtons;
                this.onButtonChange = onButtonChange;
            }

            toggleButtons() {
                this.group.selected = this.id;
                if (this.id === this.group.button1.id) {
                    this.group.button2.classList.remove('selected');
                    this.classList.add('selected');
                } else {
                    this.group.button1.classList.remove('selected');
                    this.classList.add('selected');
                }
                this.group.onButtonChange();
            }
        }

        class DraggableCircle {
            constructor(center, color, radius, eventHandlers, name = '') {
                ['Drag', 'Enter', 'Leave', 'MouseUp'].forEach(evtType => {
                    this.setEventHandler(`doOn${evtType}`,
                        eventHandlers[`on${evtType}`]);
                });
                this.color = color;
                this.radiusDefault = radius;
                this.radiusBold = radius + 3;
                this.name = name;
                this.paperCirc = new paper.Path.Circle(
                    this.circleArgs(center, this.radiusDefault)
                );
                this.addMouseEventHandlers();
            }
            defaultEventResponse() { }
            setEventHandler(name, handler) {
                if (handler instanceof Function) {
                    this[name] = () => {
                        return handler(this);
                    };
                } else {
                    this[name] = this.defaultEventResponse;
                }
            }
            get position() {
                return this.paperCirc.position;
            }
            addMouseEventHandlers() {
                this.paperCirc.onMouseDrag = (evt) => {
                    if (this.doOnDrag() === false) {
                        return;
                    }
                    shapeBeingDragged = true;
                    this.paperCirc.position.x += evt.delta.x;
                    this.paperCirc.position.y += evt.delta.y;
                    this.paperCirc.opacity = 0;
                };
                this.paperCirc.onMouseEnter = () => {
                    if (this.doOnEnter() === false) {
                        return;
                    }
                    if (shapeBeingDragged) {
                        return;
                    }
                    let newCircle = new paper.Path.Circle(
                        this.circleArgs(this.paperCirc.position,
                            this.radiusBold)
                    );
                    this.paperCirc.remove();
                    this.paperCirc = newCircle;
                    this.addMouseEventHandlers()
                };
                this.paperCirc.onMouseLeave = () => {
                    if (shapeBeingDragged) {
                        return;
                    }
                    let newCircle = new paper.Path.Circle(
                        this.circleArgs(this.paperCirc.position,
                            this.radiusDefault)
                    );
                    this.paperCirc.remove();
                    this.paperCirc = newCircle;
                    this.doOnLeave();
                    this.addMouseEventHandlers();
                }
                this.paperCirc.onMouseUp = () => {
                    if (this.doOnMouseUp() === false) {
                        return;
                    }
                    shapeBeingDragged = false;
                    this.paperCirc.opacity = 1;
                };
            }
            circleArgs(position, radius) {
                return {
                    center: position,
                    strokeColor: this.color,
                    fillColor: this.color,
                    radius: radius
                }
            }
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function isNormalInteger(str) {
            var n = Math.floor(Number(str));
            return n !== Infinity && String(n) === str && n >= 0;
        }

        function fileNameAndExt(str) {
            var file = str.split('/').pop();
            return [file.substr(0, file.lastIndexOf('.')), file.substr(file.lastIndexOf('.') + 1, file.length)]
        }

        function makeid(length, existing_ids = []) {
            var result = '';
            do {
                var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                var charactersLength = characters.length;
                for (var i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * charactersLength));
                }
            } while (existing_ids.indexOf(result) > 0)
            return result;
        }

        function checkIP(callback) {
            var result = null;
            var scriptUrl = "https://www.cloudflare.com/cdn-cgi/trace";
            $.ajax({
                url: scriptUrl,
                type: 'get',
                dataType: 'html',
                async: true,
                success: (data) => {
                    // Convert key-value pairs to JSON
                    // https://stackoverflow.com/a/39284735/452587
                    data = data.trim().split('\n').reduce(function (obj, pair) {
                        pair = pair.split('=');
                        return obj[pair[0]] = pair[1], obj;
                    }, {})
                    callback(data);
                }
            });
            return result;
        }
    </script>
    <form id=notice><label style="background-color: rgb(252, 226, 113);">Please note: the page has changed recently. If
            this box overlaps with the text below it, or if any of the buttons don't have rounded edges and black
            borders, then some features might not have loaded; a complete refresh of the page should resolve this (on
            Mac, use
            Command-Option-R).</label></form>
    <label for="img-upload-1">Upload one or more egg-counting images<br>
        <span style="font-size: small; padding-left: 15px;">
            Note: in pop-up, <span id='os-dependent-key'></span> or Shift can be used to select multiple files.
        </span>
    </label>
    <form id=img-form method=post enctype="multipart/form-data">
        <div id=img-inputs>
            <label id="img-upload-lbl" for="img-upload-1">Choose images to upload</label>
            <button hidden id=img-upload-reset type="button">Reset</button>
            <input class=img-upload type=file multiple="multiple" id="img-upload-1" name="img-upload-1">
        </div>
        <div class="preview">
            <p>No files currently selected for upload.</p>
        </div>
    </form>
    <div id=updates-toolbar>
        <div id=log-updates-title>Log updates</div>
        <button id='download-log-updates' type="button">Download</button>
    </div>
    <div id=updates-by-image></div>
    <div id=updates>
    </div>
    <button id="modalToggle" hidden data-micromodal-trigger="modal-1"></button>
    <script type="text/javascript">
        const fileTypes = [
            "image/apng",
            "image/bmp",
            "image/gif",
            "image/jpeg",
            "image/pjpeg",
            "image/png",
            "image/svg+xml",
            "image/tiff",
            "image/webp",
            "image/x-icon"
        ];

        function downloadLogUpdates() {
            var element = document.createElement('a');
            let text = '';
            logUpdates.forEach(ts => {
                text += document.getElementById(`log-update-${ts}`).innerText + '\n';
            });
            element.setAttribute('download', 'eggCountingUpdates.txt');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            element.style.display = 'none';
            document.body.appendChild(element)
            element.click();
            element.remove();
        }

        document.getElementById('download-log-updates').onclick = downloadLogUpdates;

        function updateLoginForLocalUsers(data) {
            let request = new XMLHttpRequest();
            request.open('POST', 'check_request_origin');
            let formData = new FormData();
            formData.append('ip', data.ip);
            request.send(formData);
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    let response = JSON.parse(request.response)
                    let displayAsLocal = response.local;
                    let searchParams = window.location.search;
                    let queryParams;
                    if (searchParams.length > 0) {
                        queryParams = searchParams.split('?')[1].split('&');
                    } else {
                        queryParams = [];
                    }
                    if (searchParams) {
                        document.getElementById('logout-link').href += searchParams;
                    }
                    if (displayAsLocal && queryParams.includes('origin=external')) {
                        displayAsLocal = false;
                    }
                    if (displayAsLocal) {
                        addUserSelectionDropdownToToolbar();
                    } else {
                        if (document.getElementById('username-text')) {
                            document.getElementById('username-text').style.display = '';
                        }
                    }
                }
            }
        }

        function resetUserDropdownIfNeeded() {
            window.localStorage.removeItem('user');
            let userSelect = document.getElementById('user-select');
            if (userSelect) {
                if (userSelect.options.length > 1) {
                    userSelect.value = null;
                    userSelect.dispatchEvent(new Event('change'));
                }
            }
            return true;
        }

        function updateSelectWidthBasedOnOption(evt) {
            if (!evt.target.selectedIndex || evt.target.selectedIndex === -1) {
                return;
            }
            let tempSelect = document.createElement('select'),
                tempOption = document.createElement('option');

            tempOption.textContent = evt.target.options[evt.target.selectedIndex].text;
            tempSelect.style.cssText += `
      visibility: hidden;
      position: fixed;
      `;
            tempSelect.appendChild(tempOption);
            evt.target.after(tempSelect);

            const tempSelectWidth = tempSelect.getBoundingClientRect().width;
            evt.target.style.width = `${tempSelectWidth}px`;
            tempSelect.remove();
        }

        function addUserSelectionDropdownToToolbar() {
            let request = new XMLHttpRequest();
            request.open('GET', 'users/local');
            request.send();
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    let response = JSON.parse(request.response);
                    let userDropdown = document.createElement('select');
                    userDropdown.id = 'user-select';
                    let userSelectOption = document.createElement('option');
                    userSelectOption.innerText = 'User: not set';
                    userSelectOption.value = null;
                    userDropdown.appendChild(userSelectOption);
                    response.users.forEach(user => {
                        user = capitalizeFirstLetter(user)
                        userSelectOption = document.createElement('option');
                        userSelectOption.innerText = `User: ${user}`;
                        userSelectOption.value = user;
                        userDropdown.appendChild(userSelectOption);
                    });
                    document.getElementById('userinfo-nav').prepend(userDropdown);
                    if (document.getElementById('login-link')) {
                        document.getElementById('login-link').innerText =
                            'Sign in as non-lab user';
                    }
                    userDropdown.onchange = (evt) => {
                        if (evt.target.value && evt.target.value !== 'null') {
                            window.localStorage.setItem(
                                'user', evt.target.value
                            );
                        }
                        if (evt.target.options[0].value === 'null') {
                            evt.target.remove(0);
                        }
                        updateSelectWidthBasedOnOption(evt);
                        loginLocalUser();
                    }
                    if (window.localStorage.getItem('user')) {
                        let userSelect = document.getElementById('user-select');
                        userSelect.value = window.localStorage.getItem(
                            'user');
                        userSelect.dispatchEvent(new Event('change'));
                    }
                }
            }
        }

        checkIP(updateLoginForLocalUsers);

        var parser = new UAParser();
        let wordSpan = document.getElementById('os-dependent-key')
        if (parser.getOS() === 'Mac OS') {
            wordSpan.innerText = 'Command';
        } else {
            wordSpan.innerText = 'Ctrl';
        }

        function validFileType(file) {
            return fileTypes.includes(file.type);
        }

        function deleteEntriesForImage(index) {
            socket.emit('remove-img', {
                sid,
                imgName: orderedImgNames[index]
            })
            delete chamberTypes[orderedImgNames[index]];
            delete annotations[orderedImgNames[index]];
            delete eggLayingRegions[index];
            delete rotationAngles[orderedImgNames[index]];
            delete unscaledImgBounds[orderedImgNames[index]]
            delete chamberRealignmentData[index]
            orderedImgNames.splice(index, 1);
            if (currentImgIndex >= index) {
                if (currentImgIndex > 0) {
                    currentImgIndex -= 1;
                }
                for (let i = index + 1; i < Math.max(...Object.keys(chamberRealignmentData)) + 1; i++) {
                    chamberRealignmentData[i - 1] = JSON.parse(JSON.stringify(chamberRealignmentData[i]))
                    delete chamberRealignmentData[i];
                }
            }
        }

        function getFormattedDate() {
            // source: https://stackoverflow.com/a/30948017
            var d = new Date();

            d = d.getFullYear() + "-" +
                ('0' + (d.getMonth() + 1)).slice(-2) + "-" +
                ('0' + d.getDate()).slice(-2) + " " +
                ('0' + d.getHours()).slice(-2) + ":" +
                ('0' + d.getMinutes()).slice(-2) + ":" +
                ('0' + d.getSeconds()).slice(-2);

            return d;
        }

        function addToLogUpdates(message) {
            let messageTs = Date.now();
            if (logUpdates.length === 100) {
                document.getElementById(`log-update-${logUpdates.shift()}`).remove();
            }

            let el = document.getElementById('updates-by-image');
            let addCSS = el.innerHTML.length === 0;
            el.appendChild(message);
            message.setAttribute('id', `log-update-${messageTs}`);
            message.innerText = `${getFormattedDate()}: ${message.innerText}`
            if (addCSS) {
                ['log-updates-title', 'download-log-updates'].forEach(divId => {
                    document.getElementById(divId).style.display = 'inline';
                })

                el.style.boxShadow = '0 0 1px 1px rgb(127, 156, 203) inset';
            }
            el.scrollTop = el.scrollHeight;
            logUpdates.push(messageTs)
        }

        function resetAllVariables() {
            pathAmendId = null;
            inputAmender = null;
            filesToUpload = {};
            chamberTypes = {};
            annotations = {};
            orderedImgNames = [];
            eggLayingRegions = [];
            rotationAngles = {};
            idsByOrigImgName = {};
            chamberRealignmentData = {};
            zoom = 1.0;
            idsWithEdits = new Set();
            currentImgIndex = 0;
            previousImgIndex = null;
        }

        function clearAllUpdates() {
            $('#updates').empty();
            canvas = null;
        }

        function setupOrRedrawCanvas() {
            if (!canvas) {
                setupCanvas();
            } else {
                redrawCanvas({
                    startAtBeginning: true
                });
            }
        }

        socket.on('counting-progress', (msg) => {
            if (msg.overwrite) {
                let elementToOverwrite = document.getElementsByClassName('replaceable-counting-msg')[0];
                if (elementToOverwrite) {
                    elementToOverwrite.innerText = `${elementToOverwrite.innerText.split(': ')[0]}: ${msg.data}`;
                }
                else {
                    let newPara = document.createElement('p');
                    newPara.classList.add('replaceable-counting-msg');
                    newPara.innerText = msg.data;
                    addToLogUpdates(newPara);
                }
                return;
            }
            let newPara = document.createElement('p');
            newPara.innerText = msg.data;
            addToLogUpdates(newPara);
        });


        socket.on('chamber-analysis', (msg) => {
            annotations[msg.filename] = []
            rotationAngles[msg.filename] = msg.rotationAngle;
            orderedImgNames.push(msg.filename);
            msg.bboxes.forEach((bbox) => {
                annotations[msg.filename].push({ bbox: bbox })
            });
            chamberTypes[msg.filename] = msg.chamberType;
            unscaledImgBounds[msg.filename] = {
                width: msg.width,
                height: msg.height
            }
            countingState = countingStates.pre;
            chamberRealignmentData[orderedImgNames.length - 1] = {
                file_name: orderedImgNames[orderedImgNames.length - 1],
                rotationAngle: msg.rotationAngle
            };
            setupOrRedrawCanvas();
        });
        socket.on('counting-error', (msg) => {
            let newPara = document.createElement('p');
            newPara.style.color = 'red';
            newPara.innerText = msg.data;
            addToLogUpdates(newPara);
            orderedImgNames.push(msg.filename);
            countingState = countingStates.pre;
            unscaledImgBounds[msg.filename] = {
                width: msg.width,
                height: msg.height
            }
            annotations[msg.filename] = { 'error': msg.error_type };
            setupOrRedrawCanvas();
        });
        socket.on('counting-done', (msg) => {
            countingState = countingStates.post;
            inputLbl.setAttribute('hidden', true);
            clearAllUpdates();
            setupCanvas(false);
        });
        socket.on('counting-csv', (msg) => {
            $('#updates').append(`<form id=csv-retrieve hidden action=/csvResults/${msg.data}><input hidden value='Download results' type=submit>` +
                '</input></form>');
            document.getElementById('csv-retrieve').submit();
            document.getElementById('csv-retrieve').remove();
            document.getElementById('download-csv').removeAttribute('disabled');
            clearInterval(document.getElementById('download-csv').loadingInterval);
        });
        socket.on('counting-annotations', (msg) => {
            annotations[msg.filename] = JSON.parse(msg.data);
            rotationAngles[msg.filename] = msg.rotationAngle;
            if (!msg.index) {
                orderedImgNames.push(msg.filename)
            } else {
                if (eggLayingRegions[msg.index] && eggLayingRegions[msg.index].text) {
                    eggLayingRegions[msg.index].text.remove();
                }
                delete eggLayingRegions[msg.index];
                chamberRealignmentData[msg.index].rotationAngle = rotationAngles[msg.filename];
            }
        });
        socket.on('clear-all', () => {
            if (!!document.getElementById('updates')) {
                clearAllUpdates();
            }
            annotations = {};
            orderedImgNames = [];
        });
        socket.on('clear-display', () => {
            $('#updates-by-image').empty();
        });
        socket.on('loaded-custom-mask', (msg) => {
            loadFreehandMaskOnImage(msg.maskData);
            loadGridMaskOnImage(msg.maskData, {
                clearData: false,
                convertToCanvas: true
            });
            toggleMaskNotationMode();
            document.getElementById('mask-name').value = msg.maskName;
            chamberRealignmentData[currentImgIndex].maskName = msg.maskName;
            document.getElementById('reset-masks').setAttribute('disabled', true);
            document.getElementById('save-mask').setAttribute('disabled', true);
        });
        socket.on('mask-list', (msg) => {
            maskNames = msg.names;
            addMaskSelectionButtons();
        });
        socket.on('mask-list-update', msg => {
            if (msg.fail === 'no_auth') {
                displayMaskMessage('Please sign in to save a mask.');
                return;
            }
            let maskList = document.getElementById('mask-list')
            removeOptions(maskList);
            if (msg.names.length > 0) {
                maskList.removeAttribute('disabled');
                addDropdownElement(maskList, 'Select existing mask', false)
                msg.names.forEach(name => {
                    addDropdownElement(maskList, name);
                });
                maskList.value = msg.currentMask;
            }
            displayMaskMessage('Mask saved!', 'green');
        })
        socket.on('report-ready', (msg) => {
            let el = document.getElementById('submit-error-report');
            el.removeAttribute('disabled');
            if (msg.fail === 'no_auth') {
                el.style.backgroundColor = colors.red;
                el.style.color = 'white';
                if (document.getElementById('login-link')) {
                    document.getElementById('login-link').style.fontWeight = 'bold';
                }
                let userSelect = document.getElementById('user-select');
                let userMessage;
                if (userSelect) {
                    userMessage = 'To submit, sign in via either the dropdown or' +
                        ' the "Sign in" button.'
                } else {
                    userMessage = 'Please sign in first and try again.';
                }
                document.getElementById('modal-1-title').innerText = 'Sign in'
                document.getElementById('modal-1-message').style.fontSize = '11px';
                document.getElementById('modal-1-message').innerText =
                    userMessage;
                document.getElementById('modal-1-close').removeAttribute('hidden');
                document.getElementById('modalToggle').click();
                let intervalCheck = setInterval(() => {
                    if (window.getComputedStyle(document.
                        getElementById('modal-1')).display === 'none') {
                        document.getElementById('modal-1-message').style.fontSize = '';
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        clearInterval(intervalCheck);
                    }
                }, 200)
                if (userSelect) {
                    userSelect.style.borderColor = 'red';
                    userSelect.style.fontWeight = 'bold';
                }
            } else {
                el.removeAttribute('style');
                el.innerText = 'Submitted!';
            }
            setTimeout(() => {
                el.removeAttribute('style');
                el.removeAttribute('disabled');
                let userSelect = document.getElementById('user-select');
                if (userSelect) {
                    userSelect.style.borderColor = 'black';
                    userSelect.style.fontWeight = 'normal';
                }
                if (document.getElementById('login-link')) {
                    document.getElementById('login-link').style.fontWeight = 'normal';
                }
                el.innerText = 'Submit error report for all images';
            }, 2500)
            clearInterval(el.loadingInterval);
        });
        socket.on('zip-annots-ready', (msg) => {
            $('#updates').append(`<form hidden id=annot-retrieve action=/annot-img/${msg.time}><input id=annot-retrieve-input hidden id= value='Download results' type=submit>` +
                '</input></form>')
            document.getElementById('annot-retrieve').submit();
            document.getElementById('annot-retrieve').remove();
            document.getElementById('download-imgs').innerText = 'Download annotated images';
            document.getElementById('download-imgs').removeAttribute('disabled');
            clearInterval(document.getElementById('download-imgs').loadingInterval)
        });
        socket.on('sid-from-server', (msg) => {
            if (!sid) {
                sid = msg.sid;
                setupPings();
            }
        });

        socket.on('pong', () => {
            lastPongTime = Date.now();
        })

        $(document).ready(() => {
            $("body").fadeIn(200);
            document.body.addEventListener('keydown', function (evt) {
                if (evt.key === 'Shift') {
                    shiftKeyDown = true;
                    updateBBoxOutlineForDeletion();
                    setGridNotationCursorVisibility();
                    bringGridlineToleranceBandsToFrontOrBack('front');
                    updateGridlineForDeletion();
                } else if (countingState === countingStates.post &&
                    evt.key === 'Control') {
                    hideEggOutlines();
                }

            });
            document.body.addEventListener('keyup', function (evt) {
                if (evt.key === 'Shift') {
                    shiftKeyDown = false;
                    updateBBoxOutlineForDeletion();
                    setGridNotationCursorVisibility();
                    updateGridlineForDeletion();
                } else if (countingState === countingStates.post &&
                    evt.key === 'Control') {
                    showEggOutlines();
                }
            });
            hideModal();
            setUpFileUploadDialog();
            ['login', 'signup'].forEach(action => {
                setUpActionForAuthRelatedButton(action);
            })
        });

        function hideModal(titleToCheck) {
            if (titleToCheck && document.getElementById('modal-1-title').innerText !== titleToCheck) {
                return;
            }
            document.getElementById('page-mask').style.display = 'none';
            document.getElementById('modal-1').classList.remove('is-open')
        }

        var setupPings = function () {
            setInterval(() => {
                socket.emit('ping', {
                    sid: sid
                });
                setTimeout(() => {
                    if (!lastPongTime || Date.now() - lastPongTime >= 5000) {
                        numFailedPings += 1;
                    } else if (lastPongTime && Date.now() - lastPongTime < 5000) {
                        numFailedPings = 0;
                    }
                    if (numFailedPings >= 2) {
                        document.getElementById('modal-1-close').setAttribute('hidden', true);
                        document.getElementById('modal-1-title').innerText = "Session expired";
                        document.getElementById('modal-1-message').innerText =
                            'The connection to the server has been lost; please refresh the page to continue.';
                        document.getElementById('modalToggle').click();
                    }
                }, 3000)
            }, 5000)
        }

        var setUpFileUploadDialog = function () {
            input = document.getElementById('img-upload-1');
            inputLbl = document.getElementById('img-upload-lbl');
            inputDiv = document.getElementById('img-inputs');
            inputReset = document.getElementById('img-upload-reset')
            preview = document.querySelector('.preview');
            input.addEventListener('change', updateImageDisplay);
            inputReset.onclick = handleResetClick;
        }

        function setUpActionForAuthRelatedButton(actionName) {
            let link = document.getElementById(`${actionName}-link`);
            if (!link) {
                return;
            }
            link.onclick = window['start' +
                `${capitalizeFirstLetter(actionName)}ActionViaModal`];
        }

        function addField(formToExtend, type, placeholder, opts = {
            actionOnEnter: null,
            elementId: null
        }) {
            let field = document.createElement('div');
            formToExtend.appendChild(field);
            field.classList.add('field');
            let control = document.createElement('div');
            field.appendChild(control);
            control.classList.add('control');
            let input = document.createElement('input')
            control.appendChild(input);
            input.classList.add('input', 'is-large');
            input.type = type;
            input.name = type;
            input.placeholder = placeholder;
            if (opts.actionOnEnter) {
                input.onkeydown = (e) => {
                    if (e.code === 'Enter') {
                        opts.actionOnEnter();
                    }
                }
            }
            if (opts.elementId) {
                input.setAttribute('id', opts.elementId);
            }
            return input
        }

        function addButton(formToExtend, text, clickAction) {
            let button = document.createElement('button');
            button.type = 'button';
            button.classList.add('button', 'is-block', 'is-info', 'is-large',
                'is-fullwidth')
            button.innerText = text;
            formToExtend.appendChild(button);
            button.onclick = clickAction;
            return button;
        }

        function startSignupActionViaModal() {
            document.getElementById('modal-1-title').innerText = 'Create account';
            let modalMessage = document.getElementById('modal-1-message');
            modalMessage.innerHTML =
                '<div style="margin-bottom: 15px;"><span>Save and load custom templates of egg-laying regions.</span></div>';
            let form = document.createElement('form');
            form.id = 'modal-signup-form';
            let fieldOpts = {
                actionOnEnter: () => {
                    signUpViaXHR();
                }
            };
            addField(form, 'email', 'Email', {
                ...fieldOpts, ...{
                    elementId: 'signup-email'
                }
            });
            addField(form, 'name', 'Name', {
                ...fieldOpts, ...{
                    elementId: 'signup-name'
                }
            });
            addField(form, 'password', 'Password', {
                ...fieldOpts, ...{
                    elementId: 'signup-password'
                }
            });
            let signupButton = addButton(form, 'Create account', signUpViaXHR);
            signupButton.setAttribute('id', 'signup-button');
            modalMessage.appendChild(form);
            document.getElementById('modalToggle').click();
        }

        function startLoginActionViaModal() {
            document.getElementById('modal-1-title').innerText = 'Sign in'
            let modalMessage = document.getElementById('modal-1-message');
            modalMessage.innerHTML = '';
            let loginForm = document.createElement('form');
            loginForm.id = 'modal-login-form'
            let fieldOpts = {
                actionOnEnter: () => {
                    document.getElementById('login-button').click();
                }
            }
            let emailField = addField(loginForm, 'email',
                'Your Email', fieldOpts);
            emailField.autofocus = "";
            emailField.oninput = (e) => {
                if (emailField.value.length === 0) {
                    return;
                }
                let request = new XMLHttpRequest();
                request.open('GET', '/user/exists/google/' + emailField.value);
                request.send();
                request.onreadystatechange = () => {
                    if (request.readyState === 4) {
                        let response = JSON.parse(request.response);
                        if (response.userExists) {
                            loginButton.onclick = loginViaGoogleInExternalWindow;
                        } else {
                            loginButton.onclick = loginViaXHR;
                        }

                    }
                }
            }
            addField(loginForm, 'password', 'Your Password',
                fieldOpts);
            let field = document.createElement('div');
            field.classList.add('field');
            loginForm.appendChild(field);
            let label = document.createElement('label');
            label.classList.add('checkbox');
            let input = document.createElement('input');
            input.type = 'checkbox';
            input.name = 'remember';
            input.id = 'remember-me-check';
            label.id = 'remember-me';
            label.innerText = 'Remember me';
            label.prepend(input);

            field.appendChild(label);
            let googleLoginLink = document.createElement('a');
            googleLoginLink.id = 'google-login-link';
            googleLoginLink.onclick = loginViaGoogleInExternalWindow;
            let googleLoginImg = document.createElement('img');
            googleLoginImg.id = 'google-login-img'
            googleLoginImg.src = 'static/imgs/btn_google_signin_dark_pressed_web@2x.png'
            googleLoginLink.appendChild(googleLoginImg);
            loginButton = addButton(loginForm, 'Sign in', loginViaXHR);
            loginButton.setAttribute('id', 'login-button');
            loginForm.appendChild(googleLoginLink);
            modalMessage.appendChild(loginForm);
            document.getElementById('modalToggle').click();
        }

        function loginViaGoogleInExternalWindow() {
            externalLoginWindow = window.open('/login/google');
            let loginCheckInterval = setInterval(() => {
                try {
                    if (externalLoginWindow.location.href === window.location.href.split('#')[0]) {
                        clearInterval(loginCheckInterval);
                        externalLoginWindow.close();
                        updateLoginInfoFromOAuth()
                    }
                } catch (exc) {

                }
            }, 300)
        }

        function updateLoginInfoFromOAuth() {
            let request = new XMLHttpRequest();
            request.open('GET', 'user/info/google');
            request.send();
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    let response = JSON.parse(request.response);
                    hideModal();
                    loggedIn = true;
                    ['username-text'].forEach(el => {
                        if (document.getElementById(el)) {
                            document.getElementById(el).remove();
                        }
                    });
                    let usernameText = document.createElement('span');
                    usernameText.id = 'username-text';
                    usernameText.classList.add('navbar-item');
                    usernameText.innerText =
                        `User: ${response.name} (Google)`;
                    let profilePic = document.createElement('img');
                    profilePic.id = 'google-user-pic';
                    profilePic.src = response.picture;
                    usernameText.appendChild(profilePic);
                    document.getElementById('userinfo-nav').prepend(usernameText);
                    document.getElementById('login-link').remove();
                    document.getElementById('signup-link').remove();
                    document.getElementById('logout-link').style.removeProperty('display');
                    if (document.getElementById('user-select')) {
                        document.getElementById('user-select').style.display = 'none';
                    }
                    if (document.getElementById('mask-list')) {
                        socket.emit('mask-list', { sid });
                    }
                }
            }
        }

        function signUpViaXHR() {
            let request = new XMLHttpRequest();
            request.open('POST', 'signup');
            let formData = new FormData(
                document.getElementById('modal-signup-form')
            );
            formData.append('modal', true);
            request.send(formData);
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    let response = JSON.parse(request.response);
                    if (response.success) {
                        let notification = document.createElement('div');
                        notification.id = 'acct-created';
                        notification.classList.add('notification', 'is-success');
                        notification.innerText = 'Account created! Sign in to start using it.';
                        document.getElementById('modal-1-message').prepend(notification);
                        ['email', 'name', 'password', 'button'].forEach(elName => {
                            document.getElementById(`signup-${elName}`).setAttribute('disabled', true);
                        })
                        setTimeout(() => {
                            hideModal('Create account');
                        }, 3500);
                    } else {
                        if (document.getElementById('signup-fail')) {
                            document.getElementById('signup-fail').remove();
                        }
                        let warning = document.createElement('div');
                        warning.id = 'signup-fail'
                        warning.classList.add('notification', 'is-danger');
                        warning.innerText = response.message
                        document.getElementById('modal-1-message').prepend(warning);
                    }
                }
            }
        }

        function loginLocalUser() {
            let userToLogin = document.getElementById('user-select').value;
            if (!userToLogin || userToLogin === 'null') return;
            let request = new XMLHttpRequest();
            request.open('POST', 'login/local');
            let formData = new FormData();
            formData.append('name', userToLogin);
            request.send(formData);
            request.onreadystatechange = () => {
                if (request.readyState === 4) {
                    let response = JSON.parse(request.response);
                    ['login-link', 'signup-link', 'username-text'].forEach(
                        elementName => {
                            if (document.getElementById(elementName)) {
                                document.getElementById(elementName).remove();
                            }
                        });
                    document.getElementById('logout-link'
                    ).style.removeProperty('display');
                }
            };
        }


        function loginViaXHR() {
            let request = new XMLHttpRequest();
            request.open('POST', 'login');
            let formData = new FormData(
                document.getElementById('modal-login-form'));

            formData.append('modal', true);
            request.send(formData);
            request.onreadystatechange = function () {
                if (request.readyState === 4) {
                    let response = JSON.parse(request.response)
                    if (response.success) {
                        hideModal();
                        loggedIn = true;
                        ['username-text'].forEach(el => {
                            if (document.getElementById(el)) {
                                document.getElementById(el).remove();
                            }
                        });
                        let usernameText = document.createElement('span');
                        usernameText.id = 'username-text';
                        usernameText.classList.add('navbar-item');
                        usernameText.innerText =
                            `User: ${response.name}`;
                        document.getElementById('userinfo-nav').prepend(usernameText);
                        document.getElementById('login-link').remove();
                        document.getElementById('signup-link').remove();
                        document.getElementById('logout-link').style.removeProperty('display');
                        if (document.getElementById('user-select')) {
                            document.getElementById('user-select').style.display = 'none';
                        }
                        if (document.getElementById('mask-list')) {
                            socket.emit('mask-list', { sid });
                        }
                    } else {
                        if (document.getElementById('login-fail')) {
                            document.getElementById('login-fail').remove();
                        }
                        let warning = document.createElement('div');
                        warning.id = 'login-fail'
                        warning.classList.add('notification', 'is-danger');
                        warning.innerText = 'Please check your login details and try again.'
                        document.getElementById('modal-1-message').prepend(warning);
                    }
                }
            }
        }

        var handleResetClick = function () {
            input.value = "";
            resetAllVariables();
            updateImageDisplay();
            inputReset.setAttribute('hidden', true);
            inputLbl.innerText = 'Choose images to upload';
            inputLbl.removeAttribute('hidden');
            input.removeAttribute('disabled');
            inputLbl.style.color = '';
            clearAllUpdates();
            socket.emit('reset-session', { sid })
        };

        function uploadImageBatch() {
            let allUploaded = Object.keys(filesToUpload).map(fileName =>
                filesToUpload[fileName].uploaded
            ).every(el => el);
            if (allUploaded) {
                return;
            }
            clearAllUpdates();
            var formData = new FormData();
            Object.keys(filesToUpload).forEach((fileName) => {
                if (!filesToUpload[fileName].uploaded) {
                    formData.append(fileName, filesToUpload[fileName]);
                }
                filesToUpload[fileName].uploaded = true;
            });
            formData.append('sid', sid);
            $.ajax({
                type: 'POST', url: '/upload',
                data: formData,
                contentType: false,
                cache: false,
                processData: false,
                success: function (data) {
                    console.log('Success!');
                },
            });
        }


        function missingNumInSeq(source, min = 0, max = source.length - 1) {
            // using binary search; source of code:
            // https://stackoverflow.com/a/40067211
            if (min >= max) {
                return min + 1;
            }
            let pivot = Math.floor((min + max) / 2);
            // problem is in right side. Only look at right sub array
            if (source[pivot] === pivot + 1) {
                return missingNumInSeq(source, pivot + 1, max);
            } else {
                return missingNumInSeq(source, min, pivot);
            }
        }


        function updateImageDisplay() {
            while (preview.firstChild) {
                preview.removeChild(preview.firstChild);
            }
            let imgInputs = document.getElementsByClassName('img-upload');
            Array.prototype.forEach.call(input.files, (file) => {
                let id;
                let filenameParts = fileNameAndExt(file.name);
                if (file.name in idsByOrigImgName) {
                    let suffixes = idsByOrigImgName[file.name].map(name => {
                        let firstSplit = name.split(filenameParts[0])[1];
                        if (!firstSplit.includes('_')) return '';
                        return firstSplit.split('_')[1].split('.')[0];
                    }).filter(el => el.length > 0).map(el => parseInt(el, 10))
                        .sort((a, b) => a - b);
                    let missingNum = missingNumInSeq(suffixes);
                    id = (suffixes.includes(missingNum) ?
                        idsByOrigImgName[file.name].length : missingNum).toString()
                } else {
                    id = '';
                }

                let imgUniqueName = `${filenameParts[0]}${id.length
                    > 0 ? `_${id}` : ''}.${filenameParts[1]}`
                if (file.name in idsByOrigImgName) {
                    idsByOrigImgName[file.name].push(imgUniqueName)
                } else {
                    idsByOrigImgName[file.name] = [imgUniqueName]
                }
                filesToUpload[imgUniqueName] = file
            });
            input.value = "";
            inputLbl.innerText = "Upload more images";
            inputReset.removeAttribute('hidden');
            let curFiles = [];
            let inputMapping = []
            if (Object.keys(filesToUpload).length === 0) {
                const para = document.createElement('p');
                para.textContent = 'No files currently selected for upload';
                preview.appendChild(para);
            } else {
                uploadImageBatch();
                const list = document.createElement('ol');
                preview.appendChild(list);

                Object.keys(filesToUpload).forEach((file, i) => {
                    const listItem = document.createElement('li');
                    const para = document.createElement('p');
                    const xDiv = document.createElement('div')
                    xDiv.setAttribute('class', 'close-button');
                    xDiv.setAttribute('id', `close-${i}`)
                    xDiv.assocImg = file;
                    const xStroke1 = document.createElement('div');
                    xStroke1.setAttribute('class', 'close-button-stroke1');
                    xStroke1.setAttribute('id', `close-stroke1-${i}`);
                    const xStroke2 = document.createElement('div');
                    xStroke2.setAttribute('class', 'close-button-stroke2');
                    xStroke2.setAttribute('id', `close-stroke2-${i}`);
                    xStroke1.appendChild(xStroke2);
                    xDiv.appendChild(xStroke1);
                    listItem.append(xDiv);
                    xDiv.onclick = (evt) => {
                        if (Object.keys(filesToUpload).length === 1) {
                            handleResetClick();
                            return;
                        }
                        let splitId = evt.target.id.split('-');
                        let index = parseInt(splitId[splitId.length - 1]);
                        let imgKey = document.getElementById(`close-${index}`).assocImg;
                        idsByOrigImgName[filesToUpload[imgKey].name].splice(idsByOrigImgName[filesToUpload[imgKey].name].indexOf(imgKey), 1);
                        if (idsByOrigImgName[filesToUpload[imgKey].name].length === 0) {
                            delete idsByOrigImgName[filesToUpload[imgKey].name];
                        }
                        delete filesToUpload[imgKey];
                        deleteEntriesForImage(index);
                        updateImageDisplay();
                        redrawCanvas();
                    }
                    if (validFileType(filesToUpload[file])) {
                        para.textContent = `File name ${file}, file size ${returnFileSize(filesToUpload[file].size)}.`;
                        const image = document.createElement('img');
                        image.src = URL.createObjectURL(filesToUpload[file]);

                        listItem.appendChild(image);
                        listItem.appendChild(para);
                    } else {
                        para.textContent = `File name ${file}: Not a valid file type. Update your selection.`;
                        listItem.appendChild(para);
                    }

                    list.appendChild(listItem);
                });
            };
        }

        function returnFileSize(number) {
            if (number < 1024) {
                return number + 'bytes';
            } else if (number >= 1024 && number < 1048576) {
                return (number / 1024).toFixed(1) + 'KB';
            } else if (number >= 1048576) {
                return (number / 1048576).toFixed(1) + 'MB';
            }
        }

        function setModeMarker() {
            document.getElementById('mode-marker').innerHTML = numErrors > 0 ?
                'Note: currently displaying <strong>only</strong> images that need manual alignment to be analyzed.' : '';
        }

        var setCurrentImgName = function () {
            document.getElementById('current-img').innerText =
                `Viewing image ${currentImgIndex + 1} of ${orderedImgNames.length}` +
                `: ${orderedImgNames[currentImgIndex]}` +
                (countingState !== countingStates.pre ? ' (Ctrl to hide egg outlines; shift + scroll to zoom) ' : '');
        }

        var appendToFilename = function (filename, addition) {
            return filename.replace(/(\.[\w\d_-]+)$/i, `${addition}$1`)
        }

        var displayLoadingMessage = function (dom) {
            let texts = ['Loading.', 'Loading..', 'Loading...'];
            let textIndex = 0;
            dom.loadingInterval = setInterval(() => {
                dom.innerText = texts[textIndex];
                textIndex += 1;
                if (textIndex === texts.length) {
                    textIndex = 0;
                }
            }, 400);
        }

        function imageUsesCustomMasks(index = currentImgIndex) {
            return chamberRealignmentData[index] &&
                chamberRealignmentData[index].type === 'custom';
        }

        function imageUsesGridBoxes(index = currentImgIndex) {
            return chamberRealignmentData[index].type === 'custom' &&
                chamberRealignmentData[index].customMode === 'grid';
        }

        function groupBoxesByPosition(boxes, mode) {
            let groups = [];
            let groupPropName = `${mode}Num`;
            let posPropName = `${mode === 'row' ? 'y' : 'x'}Pos`;
            let sizePropName = mode === 'row' ? 'ht' : 'wd';
            boxes.forEach(box => {
                if (groups.length === 0) {
                    chamberRealignmentData[currentImgIndex].maskBBoxes[box.id][groupPropName] = 0;
                    groups.push([box])
                    return;
                }
                let i = groups.length - 1;
                let j = groups[i].length - 1;
                if (box[posPropName] - groups[i][j][posPropName] >
                    0.5 * groups[i][j][sizePropName]) {
                    chamberRealignmentData[currentImgIndex].maskBBoxes[
                        box.id][groupPropName] = i + 1;
                    groups.push([box]);
                } else {
                    chamberRealignmentData[currentImgIndex].maskBBoxes[
                        box.id][groupPropName] = i;
                    groups[i].push(box);
                }
            });
        }

        function collectRowColCountLayoutForFreehandMasks(results, imgIndex) {
            let boxesSimplified = Object.keys(chamberRealignmentData[imgIndex].maskBBoxes).
                map((box,) => {
                    box = chamberRealignmentData[imgIndex].maskBBoxes[box];
                    return {
                        yPos: box.bounds.point.y, ht: box.bounds.height,
                        xPos: box.bounds.point.x, wd: box.bounds.width,
                        id: box.id,
                    };
                }
                );
            groupBoxesByPosition(boxesSimplified.sort((a, b) => a.yPos - b.yPos), 'row');
            groupBoxesByPosition(boxesSimplified.sort((a, b) => a.xPos - b.xPos), 'col');
            let rowColLayout = [];
            let orderedCounts = [];

            Object.keys(chamberRealignmentData[imgIndex].maskBBoxes).forEach((box, index) => {
                box = chamberRealignmentData[imgIndex].maskBBoxes[box];
                if (rowColLayout.length < box.rowNum + 1) {
                    let currentLength = rowColLayout.length
                    for (let i = 0; i < box.rowNum + 1 - currentLength; i++) {
                        rowColLayout.push([]);
                        orderedCounts.push([]);
                    }
                }
                rowColLayout[box.rowNum].push([box.colNum,
                annotations[orderedImgNames[imgIndex]][index].count]);
            });
            rowColLayout.forEach((row, index) => {
                let origRow = row;
                rowColLayout[index] = row.sort((a, b) => a[0] - b[0]);
            });
            rowColLayout.forEach((row, i) => {
                row.forEach((entry, j) => {
                    orderedCounts[i].push(entry[1]);
                    rowColLayout[i][j] = entry[0]
                })
            });
            results.rowsCols.push(rowColLayout);
            results.orderedCounts.push(orderedCounts);
            return results;
        }

        function collectRowColCountLayout() {
            let results = { rowsCols: [], orderedCounts: [] };
            orderedImgNames.forEach((name, i) => {
                if (!imageUsesCustomMasks(i)) {
                    results.rowsCols.push(null);
                    results.orderedCounts.push(null);
                    return;
                }
                if (imageUsesCustomMasks(i) && !imageUsesGridBoxes(i)) {
                    results = collectRowColCountLayoutForFreehandMasks(results, i);
                    return;
                }
                updateGridlineXYPositions(i);
                let rowColLayout = [];
                let orderedCounts = [];
                let posToColNumber = {}, posToRowNumber = {}, unusedColIndices = [];
                for (let index = 0; index < gridXYMarkers.x.length - 1; index++) {
                    posToColNumber[Math.round(gridXYMarkers.x[index])] = index;
                    unusedColIndices.push(index);
                }
                for (let index = 0; index < gridXYMarkers.y.length - 1; index++) {
                    posToRowNumber[Math.round(gridXYMarkers.y[index])] = index;
                    rowColLayout.push([]);
                    orderedCounts.push([]);
                }
                let numBoxesAdded = 0;
                Object.keys(chamberRealignmentData[i].gridlineBBoxes).forEach((key, j) => {
                    if (!chamberRealignmentData[i].gridlineBBoxes[key].selected) {
                        return;
                    }
                    let box = chamberRealignmentData[i].gridlineBBoxes[key];
                    let colNumber = posToColNumber[Math.round(box.startPoint[0] - box.kerfAmount)];
                    rowColLayout[posToRowNumber[Math.round(box.startPoint[1] - box.kerfAmount)]].push(
                        colNumber);
                    orderedCounts[posToRowNumber[Math.round(box.startPoint[1] - box.kerfAmount)]].push(
                        annotations[orderedImgNames[i]][numBoxesAdded].count
                    )
                    numBoxesAdded += 1;
                    const index = unusedColIndices.indexOf(colNumber);
                    if (index > -1) {
                        unusedColIndices.splice(index, 1);
                    }
                });
                rowColLayout = rowColLayout.filter(el => el.length !== 0);
                orderedCounts = orderedCounts.filter(el => el.length !== 0);
                rowColLayout.forEach((list, j) => {
                    let unusedColCopy = unusedColIndices.slice();
                    list.forEach((el, k) => {
                        for (let k_p = 0; k_p < unusedColCopy.length; k_p++) {
                            if (rowColLayout[j][k] > unusedColCopy[k_p]) {
                                rowColLayout[j][k] -= 1;
                                unusedColCopy = unusedColCopy.map(el => el - 1);
                            }
                        }
                    })
                    let combinedList = [];
                    for (let k = 0; k < rowColLayout[j].length; k++) {
                        combinedList.push({ col: rowColLayout[j][k], count: orderedCounts[j][k] })
                    }
                    combinedList.sort((a, b) => {
                        return a.col - b.col;
                    });
                    for (let k = 0; k < combinedList.length; k++) {
                        rowColLayout[j][k] = combinedList[k].col
                        orderedCounts[j][k] = combinedList[k].count
                    }
                });
                results.rowsCols.push(rowColLayout);
                results.orderedCounts.push(orderedCounts);
            });
            return results;
        }

        function collectEditedCounts() {
            let editedCounts = {}
            orderedImgNames.forEach((name, i) => {
                if (!eggLayingRegions[i] || eggLayingRegions[i].bad) {
                    return;
                }
                editedCounts[name] = {};
                Object.keys(eggLayingRegions[i]).forEach(region => {
                    if (eggLayingRegions[i][region].beenEdited()) {
                        editedCounts[name][eggLayingRegions[i][region].bboxIndex] =
                            eggLayingRegions[i][region].text.content;
                    }
                });
            });
            return editedCounts;
        }

        function removeOptions(selectElement) {
            var i, L = selectElement.options.length - 1;
            for (i = L; i >= 0; i--) {
                selectElement.remove(i);
            }
        }

        function updateRetryAnalysisButtonAppearance() {
            document.getElementById('retry-analysis-button').style.color =
                indicesOfUntriagedImages().length == 0 ? 'black' : colors.lightGrey;
        }

        function displayMaskMessage(message, color) {
            let maskMsgBox = document.getElementById('mask-name-message-box');
            maskMsgBox.style.color = color;
            maskMsgBox.innerText = message;
            setTimeout(() => {
                let maskMsgBox = document.getElementById('mask-name-message-box');
                maskMsgBox.style.color = 'rgb(155, 18, 29)';
                maskMsgBox.innerText = '';
            }, 3000);
        }

        function addMaskSelectionButtons() {
            displayMaskList();
            displayMaskSetterAndReloader();
            displayMaskNamingSavingUI();
        }

        function removeBoxesAndGridlines(boxType, opts = { clearData: true }) {
            let crd = chamberRealignmentData;
            let boxTypesToRemove;
            if (boxType) {
                boxTypesToRemove = [boxType];
            } else {
                boxTypesToRemove = ['maskBBoxes', 'gridlineBBoxes'];
            }
            boxTypesToRemove.forEach(boxType => {
                if (!crd[currentImgIndex][boxType]) {
                    return;
                }
                Object.keys(crd[currentImgIndex][boxType]).forEach(k => {
                    let box = crd[currentImgIndex][boxType][k];
                    if (boxType === 'gridlineBBoxes') box = box.rectPath;
                    if (box.remove) {
                        box.remove();
                        if (boxType === 'maskBBoxes') {
                            box.data.innerRect.remove();
                            box.data.corners.forEach(corner => {
                                corner.remove();
                            });
                        }
                    }
                });
                if (opts.clearData) {
                    crd[currentImgIndex][boxType] = {};
                }
            });

            if (!crd[currentImgIndex].maskGridlines) {
                return;
            }

            // remove gridlines
            orientations.forEach(lineType => {
                if (!crd[currentImgIndex].maskGridlines[lineType]) {
                    return;
                }
                Object.keys(crd[currentImgIndex].maskGridlines[lineType]).forEach(k => {
                    crd[currentImgIndex].maskGridlines[lineType][k].linePath.remove();
                    crd[currentImgIndex].maskGridlines[lineType][k].cursorToleranceBand.remove();
                });
                if (opts.clearData) {
                    crd[currentImgIndex].maskGridlines[lineType] = {};
                }
            });
        }

        function loadFreehandMaskOnImage(maskData, opts = {
            clearData: true, convertToCanvas: true
        }) {
            removeBoxesAndGridlines(null, opts);
            if (!maskData.maskBBoxes) return;
            Object.keys(maskData.maskBBoxes).forEach(k => {
                let newRandId = makeid(5, Object.keys(
                    chamberRealignmentData[currentImgIndex].maskBBoxes
                ));
                let loadedBox = maskData.maskBBoxes[k];
                let boxCoords = [loadedBox.startPoint,
                loadedBox.endPoint];
                chamberRealignmentData[currentImgIndex].maskBBoxes[newRandId] = {
                    bounds: {
                        point: {
                            x: boxCoords[0][0],
                            y: boxCoords[0][1]
                        }, width: boxCoords[1][0] - boxCoords[0][0],
                        height: boxCoords[1][1] - boxCoords[0][1]
                    },
                }
                maskCopyUpdater.registerUpdate();
            });
        }

        function loadGridMaskOnImage(maskData, opts = { clearData: true, convertToCanvas: true }) {
            removeBoxesAndGridlines(null, opts);
            let crd = chamberRealignmentData;
            // add gridlines
            if (!maskData.maskGridlines) return;
            let pad = calcPadding(0, currentImgIndex, { sf: scalingFactor, save: false });
            orientations.forEach(ort => {
                Object.keys(maskData.maskGridlines[ort]).forEach(k => {
                    let ptsToTransform;
                    if (opts.convertToCanvas) {
                        if (ort === 'horiz') {
                            ptsToTransform = [
                                [pad.left, maskData.maskGridlines[ort][k].position],
                                [pad.left + backgroundRaster.bounds.width,
                                maskData.maskGridlines[ort][k].position]];
                        } else {
                            ptsToTransform = [
                                [maskData.maskGridlines[ort][k].position,
                                pad.upper],
                                [maskData.maskGridlines[ort][k].position,
                                pad.upper + backgroundRaster.bounds.height]
                            ];
                        }
                    } else {
                        ptsToTransform = [maskData.maskGridlines[ort][k].startPoint,
                        maskData.maskGridlines[ort][k].endPoint];
                    }
                    let newGridline = new Gridline(
                        ptsToTransform[0], ptsToTransform[1],
                        ort, gridlineDoOnMouseDown
                    );

                    newGridline.id = k;
                    crd[currentImgIndex].maskGridlines[ort][
                        k
                    ] = newGridline;
                    maskCopyUpdater.registerUpdate();
                });
            });

            // add grid boxes
            Object.keys(maskData.gridlineBBoxes).forEach(k => {
                let boxArgs = [maskData.gridlineBBoxes[k].startPoint,
                maskData.gridlineBBoxes[k].endPoint];
                if (opts.convertToCanvas) {

                }
                let newBBox = new GridlineBox(
                    boxArgs[0], boxArgs[1],
                    {
                        ptsToOffset: {
                            start: [false, false],
                            end: [false, false]
                        }
                    }
                )
                newBBox.id = k;
                if (maskData.gridlineBBoxes[k].selected) {
                    newBBox.toggleSelected();
                }
                crd[currentImgIndex].gridlineBBoxes[k] = newBBox;
                maskCopyUpdater.registerUpdate();
            });
            updateRetryAnalysisButtonAppearance();
        }

        function addGridlinesToSaveData(key, dataOut) {
            if (!dataOut[key]) {
                dataOut[key] = { maskGridlines: { horiz: {}, vert: {} } };
            } else {
                dataOut[key][maskGridlines] = { horiz: {}, vert: {} };
            }
            Object.keys(dataOut[key].maskGridlines).forEach(lineType => {
                Object.keys(chamberRealignmentData[key].maskGridlines[lineType]).forEach(lineKey => {
                    dataOut[key].maskGridlines[lineType][lineKey] =
                        chamberRealignmentData[key].maskGridlines[lineType][lineKey].reduced;
                })
            })
            return dataOut;
        }

        function addGridlineBoxesToSaveData(key, dataOut) {
            if (!dataOut[key]) dataOut[key] = { gridlineBBoxes: {} };
            else dataOut[key].gridlineBBoxes = {};
            Object.keys(chamberRealignmentData[key].gridlineBBoxes).forEach(boxKey => {
                dataOut[key].gridlineBBoxes[boxKey] = chamberRealignmentData[key].gridlineBBoxes[boxKey].reduced;
            });
            return dataOut;
        }

        function addFreehandBoxesToSaveData(key, dataOut) {
            if (!dataOut[key]) dataOut[key] = { maskBBoxes: {} };
            else dataOut[key].maskBBoxes = {};
            Object.keys(chamberRealignmentData[key].maskBBoxes).forEach(boxKey => {
                let box = chamberRealignmentData[key].maskBBoxes[boxKey];
                dataOut[key].maskBBoxes[boxKey] = {
                    startPoint: [box.bounds.x, box.bounds.y],
                    endPoint: [box.bounds.x + box.bounds.width,
                    box.bounds.y + box.bounds.height]
                };
            })
            return dataOut;
        }

        function saveCustomMask() {
            if (!loggedIn) {
                displayMaskMessage('Please sign in to save a mask.');
                return;
            }
            let reducedData = {};
            reducedData = addGridlinesToSaveData(currentImgIndex, reducedData);
            reducedData = addGridlineBoxesToSaveData(currentImgIndex, reducedData);
            reducedData = addFreehandBoxesToSaveData(currentImgIndex, reducedData);
            socket.emit('save-custom-mask', {
                maskData: reducedData[currentImgIndex],
                sid,
                maskName: document.getElementById('mask-name').value
            });
        }

        function markMaskAsEdited() {
            document.getElementById('save-mask').removeAttribute('disabled');
            if (document.getElementById('mask-list').value !== 'Select existing mask') {
                document.getElementById('reset-masks').removeAttribute('disabled');
            }
        }

        function displayMaskNamingSavingUI() {
            if (document.getElementById('mask-namer-and-saver')) {
                return;
            }
            let helpPane = document.getElementById('help-pane');
            let newButtonGroup = document.createElement('div');
            newButtonGroup.classList.add('mask-button-set');
            newButtonGroup.id = 'mask-namer-and-saver';
            let maskNamingField = document.createElement('input');
            maskNamingField.setAttribute('id', 'mask-name');
            maskNamingField.placeholder = 'Mask name';
            newButtonGroup.appendChild(maskNamingField);
            helpPane.append(newButtonGroup);
            $('#mask-namer-and-saver').append(dividerString());
            let maskSaveButton = document.createElement('button');
            maskSaveButton.id = 'save-mask';
            maskSaveButton.setAttribute('name', 'save-mask');
            maskSaveButton.setAttribute('disabled', true);
            maskSaveButton.innerHTML = 'Save';
            newButtonGroup.appendChild(maskSaveButton);
            maskSaveButton.onclick = saveCustomMask;
            $('#mask-name').on('input', onMaskNameChange);
            let warningMessage = document.createElement('span');
            warningMessage.id = 'mask-name-message-box';
            helpPane.appendChild(warningMessage);
        }

        function onMaskNameChange() {
            let maskSaveButton = document.getElementById('save-mask');
            if (this.value.length === 0) {
                maskSaveButton.setAttribute('disabled', true);
            } else {
                maskSaveButton.removeAttribute('disabled');
            }
            let maskNameMessage = document.getElementById('mask-name-message-box');
            if (maskNames.includes(this.value)) {
                maskNameMessage.innerText = 'Warning: mask name already in use. Saving will overwrite existing data.';
            } else {
                maskNameMessage.innerText = '';
            }
        }

        function toggleMaskNotationMode() {
            $('#mode-specific-buttons').empty();
            $('#lock-gridlines.div').empty();
            if (maskNotationButtonGroup.selected === 'grid-edit-button') {
                chamberRealignmentData[currentImgIndex].customMode = 'grid';
                addGridNotationUI();
            } else {
                chamberRealignmentData[currentImgIndex].customMode = 'freehand';
                addFreehandNotationUI();
            }
            maskCopyUpdater.registerUpdate();
            document.getElementById('mask-edit-instructions').innerHTML =
                maskEditInstructions[chamberRealignmentData[currentImgIndex].customMode];
            currentMaskBBox = null;
        }

        function toggleDisabledInHTMLCollection(collection, setToDisabled, idsToSkip = []) {
            for (let item of collection) {
                if (idsToSkip.includes(item.id)) continue;
                if (setToDisabled) {
                    item.setAttribute('disabled', true);
                } else {
                    item.removeAttribute('disabled');
                }
            }
        }

        function transformImageOnly(evt) {
            if (evt.deltaY !== undefined) {
                zoomImageOnly(evt);
            } else if (shiftKeyDown) {
                rotateImageOnly(evt);
            } else {
                panImageOnly(evt);
            }
        }

        function zoomImageOnly(evt) {
            let diffInScaling = 0.01 * (evt.deltaY > 0 ? 1 : -1)
            let oldScaling = chamberRealignmentData[currentImgIndex].scaling;
            chamberRealignmentData[currentImgIndex].scaling += diffInScaling;
            backgroundRaster.scale(chamberRealignmentData[currentImgIndex].scaling / oldScaling);
            calcPadding();
        }

        function calcPadding(rotationAngle = 0, index = currentImgIndex, opts = {
            save: true
        }) {
            if (!opts.sf) {
                opts.sf = scalingFactor * (chamberRealignmentData[index] && chamberRealignmentData[index].scaling ? chamberRealignmentData[index].scaling : 1)
            }
            let wd = unscaledImgBounds[orderedImgNames[index]].width;
            let ht = unscaledImgBounds[orderedImgNames[index]].height;
            let uPadTemp = 0.5 * (canvasHeight - ht * opts.sf)
                + Math.abs(0.5 * Math.tan(rotationAngle) * wd * opts.sf);
            let lPadTemp = 0.5 * (canvasWidth - wd * opts.sf)
                + Math.abs(0.5 * Math.tan(rotationAngle) * ht * opts.sf);
            if (opts.save !== true) {
                return { upper: uPadTemp, left: lPadTemp };
            }
            upperPadding = uPadTemp;
            leftPadding = lPadTemp;
            chamberRealignmentData[index].padding = {
                upper: uPadTemp,
                left: lPadTemp
            };
        }

        function rotateImageOnly(evt) {
            const maxDegreesRotation = 20;
            // v1: the original vector
            let v1 = evt.point.subtract(evt.delta).subtract(backgroundRaster.position);
            // v2: the current vector
            let v2 = evt.point.subtract(backgroundRaster.position);
            let rotAngle = Math.atan2(v1.x * v2.y - v1.y * v2.x,
                v1.x * v2.x + v2.y * v2.y);
            let potentialRotationAngle = chamberRealignmentData[currentImgIndex].rotationAngle - rotAngle;
            if (Math.abs(180 * potentialRotationAngle / Math.PI) > maxDegreesRotation) return;
            backgroundRaster.rotate(180 * rotAngle / Math.PI);
            chamberRealignmentData[currentImgIndex].rotationAngle -= rotAngle;
            rotationAngles[orderedImgNames[currentImgIndex]] = chamberRealignmentData[currentImgIndex].rotationAngle;
            calcPadding();
        }

        function panImageOnly(evt) {
            [backgroundRaster, imageCenterMarker].forEach(path => {
                path.position = path.position.add(evt.delta);
            })

            chamberRealignmentData[currentImgIndex].imageTranslation[0] += evt.delta.x;
            chamberRealignmentData[currentImgIndex].imageTranslation[1] += evt.delta.y;
            calcPadding();
        }

        function rotateBoxesAndOutlinesForCustomMask(id) {
            let angle = 180 * chamberRealignmentData[currentImgIndex].rotationAngle /
                Math.PI;
            if (angle === 0) return;
            let center = backgroundRaster.position;
            let reg = eggLayingRegions[currentImgIndex][id];
            reg.outline.rotate(angle, center);
            reg.fill.rotate(angle, center);
            if (reg.eggShapes) {
                reg.eggShapes.forEach(shape => {
                    shape.rotate(angle, center);
                });
            }
        }

        function maskLocked() {
            if (!document.getElementById('lock-mask')) return false;
            return document.getElementById('lock-mask').innerHTML !== lockMaskText;
        }

        function toggleDisabledAttrOfMaskEditingButtons(setToDisabled) {
            let uiPane = document.getElementById('help-pane');
            toggleDisabledInHTMLCollection(uiPane.getElementsByTagName('button'), setToDisabled, ['lock-mask']);
            toggleDisabledInHTMLCollection(uiPane.getElementsByTagName('select'),
                setToDisabled);
            toggleDisabledInHTMLCollection(uiPane.getElementsByTagName('input'), setToDisabled);
        }

        function toggleBackgroundImageMarker() {
            if (maskLocked()) {
                imageCenterMarker = new paper.Path.Circle(backgroundRaster.position, 5);
                imageCenterMarker.fillColor = 'red';
            } else if (imageCenterMarker) {
                imageCenterMarker.remove();
                imageCenterMarker = null;
            }
        }

        function lockMaskOnClick(event) {
            let enteringLock = event.target.innerHTML === lockMaskText;
            let unlockedText = maskEditInstructions[
                chamberRealignmentData[currentImgIndex].customMode];
            event.target.innerHTML = enteringLock ? 'Unlock mask' : lockMaskText;
            toggleDisabledAttrOfMaskEditingButtons(enteringLock);
            document.getElementById('mask-edit-instructions').innerHTML = enteringLock ? imageTransformInstructions : unlockedText;
            setGridNotationCursorVisibility();
            toggleBackgroundImageMarker();
        }

        function addLockMaskButton() {
            let parentDiv = document.createElement('div');
            parentDiv.classList.add('mask-button-set');
            document.getElementById('help-pane').appendChild(parentDiv);
            let lockMaskButton = document.createElement('button');
            lockMaskButton.id = 'lock-mask';
            lockMaskButton.innerHTML = lockMaskText;
            parentDiv.appendChild(lockMaskButton);
            lockMaskButton.onclick = lockMaskOnClick;
        }

        function addFreehandNotationUI(opts = { draw: true }) {
            removeBoxesAndGridlines('gridlineBBoxes', { clearData: false });
            setGridNotationCursorVisibility();
            let existingFreehandBoxIds = Object.keys(
                chamberRealignmentData[currentImgIndex].maskBBoxes
            )
            existingFreehandBoxIds.forEach(id => {
                let existingBox = chamberRealignmentData[currentImgIndex].maskBBoxes[
                    id
                ];
                let bounds = [[existingBox.bounds.point.x,
                existingBox.bounds.point.y]];
                bounds.push([bounds[0][0] + existingBox.bounds.width,
                bounds[0][1] + existingBox.bounds.height]);
                createMaskBBox(bounds, { redraw: opts.draw });
                delete chamberRealignmentData[currentImgIndex].maskBBoxes[
                    id
                ];
            });
        }

        function gridlineDoOnMouseDown(evt) {
            deleteBoxesTouchingRemovedGridline(evt.target);
            markMaskAsEdited();
            delete chamberRealignmentData[currentImgIndex].maskGridlines[evt.target.owner.orientation][evt.target.owner.id];
            maskCopyUpdater.registerUpdate();
        }

        function addGridlineNotation(evt) {
            if (countingState !== countingStates.pre ||
                !tempCursor ||
                gridlinesLocked() ||
                maskLocked()) {
                return;
            }
            markMaskAsEdited();
            if (horizSelected()) {
                orientation = 'horiz';
            } else {
                orientation = 'vert';
            }
            let newGridLine = new Gridline(
                tempCursor.side1.data.lineBounds.from,
                tempCursor.side1.data.lineBounds.to,
                orientation,
                gridlineDoOnMouseDown
            );
            maskCopyUpdater.registerUpdate();
            chamberRealignmentData[currentImgIndex].maskGridlines[orientation][newGridLine.linePath.id] = newGridLine;
            bisectBoxesByAddedGridline(newGridLine.linePath);
            tempCursor.side1.remove();
            tempCursor.side2.remove();
            tempCursor = null;
        }

        function horizSelected() {
            if (!gridlineOrientationButtonGroup) {
                return null;
            }
            return gridlineOrientationButtonGroup.selected.split('-')[0] === 'horiz'
        }

        function bringGridlineToleranceBandsToFrontOrBack(mode) {
            if (!(chamberRealignmentData[currentImgIndex] &&
                chamberRealignmentData[currentImgIndex].maskGridlines)) {
                return;
            }
            let methodToCall = mode === 'front' ? 'bringToFront' : 'sendToBack';
            ['horiz', 'vert'].forEach(ori => {
                Object.keys(
                    chamberRealignmentData[
                        currentImgIndex].maskGridlines[ori]).forEach(gridlineId => {
                            chamberRealignmentData[
                                currentImgIndex
                            ].maskGridlines[
                                ori][gridlineId].cursorToleranceBand[methodToCall]();
                        });
            })
        }

        function previewGridlineMatchesOverlap() {
            return overlappingExistingGridline && overlappingExistingGridline.status
                && ((overlappingExistingGridline.orientation === 'horiz' &&
                    horizSelected()) || (
                        overlappingExistingGridline.orientation === 'vert' &&
                        horizSelected() === false
                    ));
        }

        function setGridNotationCursorVisibility() {
            if (!tempCursor) {
                return;
            }
            if (shiftKeyDown || gridlinesLocked() ||
                maskLocked() || editingFreehandMasks() ||
                cursorOnCanvas === false || previewGridlineMatchesOverlap()
            ) {
                tempCursor.side1.remove();
                tempCursor.side2.remove()
                tempCursor = null;
                tempCursorCoordText.remove();
                tempCursorCoordText = null;
                tempCursorUnderlay.remove();
                tempCursorUnderlay = null;
            }
        }

        function addGridNotationCursor(evt) {
            let cursorSplitWidth = 2;
            if (countingState !== countingStates.pre) return;
            if (!document.getElementById('help-pane') || !document.getElementById('grid-edit-button')) return;
            if (maskNotationButtonGroup.selected !== 'grid-edit-button'
            ) {
                return;
            }
            if (maskLocked()) return;

            setGridNotationCursorVisibility();
            if (gridlinesLocked() || previewGridlineMatchesOverlap()) return;
            let isH = horizSelected();
            let lineBounds, lineBoundsSplit;
            let imgStartX = backgroundRaster.position.x -
                backgroundRaster.bounds.width / 2;
            let imgStartY = backgroundRaster.position.y - backgroundRaster.bounds.height / 2;
            if (isH) {
                lineBounds = {
                    from: [imgStartX, evt.point.y],
                    to: [backgroundRaster.position.x + backgroundRaster.bounds.width / 2, evt.point.y]
                };
                lineBoundsSplit = {
                    side1: {
                        from: [imgStartX, evt.point.y],
                        to: [evt.point.x - cursorSplitWidth, evt.point.y]
                    },
                    side2: {
                        from: [evt.point.x + cursorSplitWidth,
                        evt.point.y],
                        to: [backgroundRaster.position.x + backgroundRaster.bounds.width / 2,
                        evt.point.y]
                    }
                }
            } else {
                lineBounds = {
                    from: [evt.point.x, imgStartY],
                    to: [
                        evt.point.x, backgroundRaster.position.y +
                        backgroundRaster.bounds.height / 2
                    ]
                }
                lineBoundsSplit = {
                    side1: {
                        from: [evt.point.x, imgStartY],
                        to: [evt.point.x, evt.point.y - cursorSplitWidth]
                    },
                    side2: {
                        from: [evt.point.x, evt.point.y + cursorSplitWidth],
                        to: [evt.point.x,
                        backgroundRaster.position.y + backgroundRaster.bounds.height / 2]
                    }
                }
            }
            if (!backgroundRaster.contains(evt.point)) return;
            let cursorPosOffset = new paper.Point(evt.point.x - 3, evt.point.y - 12);
            if (!tempCursorCoordText) {
                tempCursorCoordText = new paper.PointText(new paper.Point(
                    evt.point.x + 5, evt.point.y - 30
                ));
            }
            let cursorInImgRefPt = evt.point.subtract(new paper.Point(imgStartX, imgStartY))
            if (isH) {
                tempCursorCoordText.content = `Y: ${cursorInImgRefPt.y}`;
            } else {
                tempCursorCoordText.content = `X: ${cursorInImgRefPt.x}`;
            }
            tempCursorCoordText.position = cursorPosOffset;
            if (!tempCursorCoordText.isInside(backgroundRaster.bounds)) {
                tempCursorCoordText.position.y += 15;
                tempCursorCoordText.position.x -= 15;
            }
            if (!tempCursorUnderlay) {
                tempCursorUnderlay = new paper.Shape.Rectangle(tempCursorCoordText.bounds.topLeft, tempCursorCoordText.bounds.bottomRight);
                tempCursorUnderlay.fillColor = 'white';
                tempCursorUnderlay.opacity = 0.3;
                tempCursorUnderlay.insertBelow(tempCursorCoordText);
            } else {
                tempCursorUnderlay.position = tempCursorCoordText.position;
                tempCursorUnderlay.size = new paper.Size(tempCursorCoordText.bounds.width,
                    tempCursorCoordText.bounds.height);
            }
            if (!tempCursor) {
                if (shiftKeyDown || gridlinesLocked()) return;

                tempCursor = {
                    side1: paper.Path.Line({
                        ...lineBoundsSplit.side1, ...{ strokeColor: 'black' }
                    }),
                    side2: paper.Path.Line({
                        ...lineBoundsSplit.side2, ... { strokeColor: 'black' }
                    })
                }
            } else {
                tempCursor.side1.segments[0].point = new paper.Point(...lineBoundsSplit.side1.from);
                tempCursor.side1.segments[1].point = new paper.Point(...lineBoundsSplit.side1.to);
                tempCursor.side2.segments[0].point = new paper.Point(...lineBoundsSplit.side2.from);
                tempCursor.side2.segments[1].point = new paper.Point(...lineBoundsSplit.side2.to);
            }
            tempCursor.side1.data.lineBounds = lineBounds;
        }

        function addGridNotationUI(opts = { draw: true }) {
            let parentDiv = document.createElement('div');
            parentDiv.classList.add('mask-button-set');
            parentDiv.id = 'mode-switch-button-group';
            document.getElementById('mode-specific-buttons').appendChild(parentDiv)

            let orientationLabel = {
                id: 'line-orientation-label',
                innerHTML: 'Gridline orientation'
            };
            let horizontalLineButton = {
                id: 'horiz-gridline-button',
                innerHTML: 'Horiz.'
            };
            let verticalLineButton = {
                id: 'vert-gridline-button',
                innerHTML: 'Vert.'
            };
            gridlineOrientationButtonGroup = new ButtonGroup(
                parentDiv,
                orientationLabel,
                horizontalLineButton,
                verticalLineButton,
                () => { }
            );

            let lockGridlinesDiv = document.createElement('div');
            lockGridlinesDiv.classList.add('mask-button-set');
            lockGridlinesDiv.id = 'lock-gridlines-div';
            document.getElementById('mode-specific-buttons').appendChild(lockGridlinesDiv);

            let lockGridlinesButton = document.createElement('button');
            lockGridlinesButton.id = 'lock-gridlines-button';
            lockGridlinesButton.innerHTML = lockGridlinesText;
            lockGridlinesDiv.appendChild(lockGridlinesButton);
            lockGridlinesButton.onclick = lockOrUnlockGridlines;
            if (opts.draw) {
                loadGridMaskOnImage(chamberRealignmentData[currentImgIndex],
                    {
                        clearData: false,
                        convertToCanvas: false
                    });
            }
        }

        function gridlinesLocked() {
            if (countingState !== countingStates.pre ||
                !document.getElementById('lock-gridlines-button')) return false;
            return document.getElementById('lock-gridlines-button').innerHTML !== lockGridlinesText;
        }

        function editingFreehandMasks() {
            if (countingState !== countingStates.pre ||
                !document.getElementById('grid-edit-button')) {
                return false;
            }
            return maskNotationButtonGroup.selected === 'freehand-edit-button';
        }

        function lockOrUnlockGridlines() {
            let lockButton = document.getElementById('lock-gridlines-button');
            if (gridlinesLocked()) {
                lockButton.innerHTML = lockGridlinesText;
                bringGridlineToleranceBandsToFrontOrBack('front');
            } else {
                lockButton.innerHTML = 'Unlock gridlines';
                bringGridlineToleranceBandsToFrontOrBack('back');
            }
        }


        class Gridline {
            constructor(
                startPoint,
                endPoint,
                orientation,
                doOnMouseDown
            ) {
                this.startPoint = startPoint;
                this.endPoint = endPoint;
                this.orientation = orientation;
                this.doOnMouseDown = doOnMouseDown;
                this.restoreLinePath();
                this.id = this.linePath.id;
            }
            setEventHandlers() {
                this.cursorToleranceBand.onMouseEnter = event => {
                    if (maskLocked()) {
                        return;
                    }
                    overlappingExistingGridline = {
                        status: true,
                        orientation: this.orientation,
                        id: this.id
                    };
                    if (shiftKeyDown) {
                        this.linePath.strokeColor = 'red';
                    }
                };
                this.cursorToleranceBand.onMouseDown = event => {
                    if (!shiftKeyDown || maskLocked()) return;
                    this.linePath.remove();
                    this.cursorToleranceBand.remove();
                    this.doOnMouseDown(event);
                }
                this.cursorToleranceBand.onMouseLeave = event => {
                    this.linePath.strokeColor = 'black';
                    overlappingExistingGridline = {
                        status: false
                    };
                }
            }
            restoreLinePath() {
                this.linePath = paper.Path.Line({
                    ...{ from: this.startPoint, to: this.endPoint },
                    ...{
                        strokeColor: 'black',
                        strokeWidth: gridlineStrokeWidth
                    }
                });
                this.cursorToleranceBand = paper.Path.Line({
                    ...{ from: this.startPoint, to: this.endPoint },
                    ...{
                        strokeColor: 'orange',
                        strokeWidth: gridlineStrokeWidth + 5,
                        opacity: 0
                    }
                })
                this.linePath.owner = this;
                this.cursorToleranceBand.owner = this;
                this.setEventHandlers();
            }
            get reduced() {
                return {
                    orientation: this.orientation,
                    id: this.id,
                    ... (this.orientation ===
                        'horiz' && { position: this.startPoint[1] }),
                    ... (this.orientation ===
                        'vert' && { position: this.startPoint[0] })
                }
            }
        }

        class PeriodicUpdater {
            constructor(actionWhenUpdating, secondsBetweenChecks = 5) {
                this.secondsBetweenChecks = secondsBetweenChecks
                this.updateNeeded = false;
                this.actionWhenUpdating = actionWhenUpdating;
                this.setupUpdates();
            }
            registerUpdate() {
                this.updateNeeded = true;
            }
            setupUpdates() {
                this.interval = setInterval(() => {
                    if (this.updateNeeded) {
                        this.actionWhenUpdating();
                        this.updateNeeded = false;
                    }
                }, 1000 * this.secondsBetweenChecks);
            }
        }

        class GridlineBox {
            constructor(startPoint, endPoint,
                opts = {
                    ptsToOffset: {
                        start: [true, true],
                        end: [true, true]
                    }
                },
                doOnToggle = updateRetryAnalysisButtonAppearance) {
                this.opacityVals = {
                    hidden: 0,
                    hover: 0.25,
                    selected: 0.5
                }
                this.kerfAmount = gridlineStrokeWidth / 2;
                this.startPoint = startPoint;
                this.endPoint = endPoint;
                this.doOnToggle = doOnToggle;
                this.opts = opts;
                this.offsetByKerf(opts.ptsToOffset);
                this.selected = false;
                this.restoreRectPath();
                this.id = this.rectPath.id;
            }

            toggleSelected() {
                markMaskAsEdited();
                this.selected = !this.selected;
                if (this.selected) {
                    this.rectPath.opacity = this.opacityVals.selected;
                } else {
                    this.rectPath.opacity = this.opacityVals.hover;
                }
                this.doOnToggle();
                maskCopyUpdater.registerUpdate()
            }
            offsetByKerf(ptsToOffset) {
                let ptNames = { start: 'startPoint', end: 'endPoint' };
                Object.keys(ptsToOffset).forEach(key => {
                    ptsToOffset[key].forEach((pt, j) => {
                        if (pt) {
                            this[ptNames[key]][j] += (key === 'start' ? 1 : -1)
                                * this.kerfAmount;
                        }
                    })
                })
            }
            setEventHandlers() {
                this.rectPath.onMouseEnter = (event) => {
                    if (event.target.data.owner.selected || !gridlinesLocked()) return;
                    event.target.opacity = this.opacityVals.hover;
                }
                this.rectPath.onMouseLeave = (event) => {
                    if (event.target.data.owner.selected) return;
                    event.target.opacity = this.opacityVals.hidden;
                }
                this.rectPath.onMouseDown = (event) => {
                    if (!gridlinesLocked()) return;
                    event.target.data.owner.toggleSelected();
                }
            }
            restoreRectPath() {
                this.rectPath = new paper.Path.Rectangle(
                    new paper.Point(...this.startPoint),
                    new paper.Point(...this.endPoint)
                );
                this.rectPath.opacity = this.opacityVals[
                    this.selected ? 'selected' : 'hidden'];
                this.rectPath.fillColor = 'green';
                this.rectPath.data.owner = this;
                this.setEventHandlers();
            }
            get reduced() {
                return {
                    startPoint: this.startPoint,
                    endPoint: this.endPoint,
                    opts: this.opts,
                    selected: this.selected,
                    id: this.id
                }
            }
        }

        function updateGridlineXYPositions(index = currentImgIndex) {
            let keys = [['x', 'vert'], ['y', 'horiz']];
            gridXYMarkers = {};
            keys.forEach(keyPair => {
                gridXYMarkers[keyPair[0]] = Object.keys(
                    chamberRealignmentData[index].maskGridlines[keyPair[1]]).map(
                        key => chamberRealignmentData[index].maskGridlines[keyPair[1]][key].linePath.position[keyPair[0]]
                    ).sort(function (a, b) {
                        return a - b;
                    })
            });
        }

        function setUpTempRasterRect() {
            tempRasterRect = new paper.Path.Rectangle(backgroundRaster.bounds);
            tempRasterRect.opacity = 0;
        }

        function tearDownTempRasterRect() {
            tempRasterRect.remove();
            tempRasterRect = null;
        }

        function convertFreehandBoxSelectionsToBBoxes(key) {
            chamberRealignmentData[key].bboxes = [];
            Object.keys(chamberRealignmentData[key].maskBBoxes).forEach(k => {
                let box = chamberRealignmentData[key].maskBBoxes[k];
                chamberRealignmentData[key].regionsToIgnore.push(
                    !backgroundRaster.intersects(box) &&
                    !box.isInside(backgroundRaster.bounds)
                );

                chamberRealignmentData[key].bboxes.push([
                    (box.bounds.point.x - chamberRealignmentData[key].padding.left) / scalingFactor,
                    (box.bounds.point.y - chamberRealignmentData[key].padding.upper) / scalingFactor,
                    box.bounds.width / scalingFactor,
                    box.bounds.height / scalingFactor])
            });
        }

        function convertGridBoxSelectionsToBBoxes(key) {
            chamberRealignmentData[key].bboxes = [];
            Object.keys(chamberRealignmentData[key].gridlineBBoxes).filter(k => {
                return chamberRealignmentData[key].gridlineBBoxes[k].selected
            }).forEach(k => {
                let box = chamberRealignmentData[key].gridlineBBoxes[k];
                chamberRealignmentData[key].regionsToIgnore.push(
                    !backgroundRaster.intersects(box.rectPath) &&
                    !box.rectPath.isInside(backgroundRaster.bounds));

                chamberRealignmentData[key].bboxes.push([
                    (box.startPoint[0] - chamberRealignmentData[key].padding.left) / scalingFactor,
                    (box.startPoint[1] - chamberRealignmentData[key].padding.upper) / scalingFactor,
                    (box.endPoint[0] - box.startPoint[0]) / scalingFactor,
                    (box.endPoint[1] - box.startPoint[1]) / scalingFactor
                ]);
            });
        }

        function deleteBoxesTouchingRemovedGridline(gridline) {
            let boxes = chamberRealignmentData[currentImgIndex].gridlineBBoxes
            Object.keys(chamberRealignmentData[currentImgIndex].gridlineBBoxes).forEach(key => {
                let box = chamberRealignmentData[currentImgIndex].gridlineBBoxes[key];
                let intersects = false, coord, offset;
                if (gridline.owner.orientation === 'vert') {
                    coord = 'x';
                    offset = 'width'
                } else {
                    coord = 'y';
                    offset = 'height'
                }
                if (gridline.position[coord] === box.rectPath.bounds[coord] - 1 ||
                    gridline.position[coord] === box.rectPath.bounds[coord]
                    + box.rectPath.bounds[offset] + 1) {
                    intersects = true;
                }
                if (!intersects) {
                    return;
                }
                box.rectPath.remove();
                delete chamberRealignmentData[currentImgIndex].gridlineBBoxes[box.id];
            });
            updateGridlineXYPositions();
            if (gridline.owner.orientation === 'horiz') {
                dim1 = 'y';
                dim2 = 'x';
            } else {
                dim1 = 'x'
                dim2 = 'y';
            }
            if (
                gridline.position[dim1] === gridXYMarkers[dim1][0] ||
                gridline.position[dim1] === gridXYMarkers[dim1][
                gridXYMarkers[dim1].length - 1
                ]
            ) return;
            let gridIndex = gridXYMarkers[dim1].indexOf(gridline.position[dim1]);
            let bounds = [gridXYMarkers[dim1][gridIndex - 1],
            gridXYMarkers[dim1][gridIndex + 1]];
            for (let j = 0; j < gridXYMarkers[dim2].length - 1; j++) {
                let args = [
                    [gridXYMarkers[dim2][j], bounds[0]],
                    [gridXYMarkers[dim2][j + 1], bounds[1]]
                ]

                if (dim1 === 'x') {
                    args = args.map(el => el.reverse());
                }

                let newGridlineBox = new GridlineBox(...args);
                chamberRealignmentData[currentImgIndex].gridlineBBoxes[newGridlineBox.id] = newGridlineBox;
            }
        }

        function bisectBoxesByAddedGridline(gridline) {
            let foundBisection = false;
            if (!chamberRealignmentData[currentImgIndex].gridlineBBoxes) return;
            Object.keys(chamberRealignmentData[currentImgIndex].gridlineBBoxes).forEach(key => {
                let box = chamberRealignmentData[currentImgIndex].gridlineBBoxes[key];
                if (!box.rectPath.intersects(gridline)) {
                    return;
                }
                foundBisection = true;
                let startPoints = [], endPoints = [];
                let ptsToOffset = [{
                    start: [false, false],
                },
                {
                    end: [false, false]
                }];
                startPoints.push([box.startPoint[0], box.startPoint[1]]);
                endPoints.push([box.endPoint[0], box.endPoint[1]])
                if (gridline.owner.orientation === 'horiz') {
                    endPoints.unshift([box.endPoint[0], gridline.position.y]);
                    ptsToOffset[0].end = [false, true];
                    startPoints.push([box.startPoint[0], gridline.position.y]);
                    ptsToOffset[1].start = [false, true];
                } else {
                    endPoints.unshift([gridline.position.x, box.endPoint[1]]);
                    ptsToOffset[0].end = [true, false];
                    startPoints.push([gridline.position.x, box.startPoint[1]]);
                    ptsToOffset[1].start = [true, false];
                }
                let origBoxWasSelected = box.selected;
                box.rectPath.remove();
                startPoints.forEach((startPoint, i) => {
                    let newShape = new GridlineBox(startPoint, endPoints[i],
                        { ptsToOffset: ptsToOffset[i] });
                    if (origBoxWasSelected) {
                        newShape.toggleSelected();
                    }
                    newShape.rectPath.insertBelow(gridline);
                    chamberRealignmentData[currentImgIndex].gridlineBBoxes[newShape.id] = newShape;

                });
                delete chamberRealignmentData[currentImgIndex].gridlineBBoxes[box.rectPath.id];
            });
            if (foundBisection) return;
            updateGridlineXYPositions();
            let newGridlineBox, dim1, dim2;

            if (gridline.owner.orientation === 'horiz') {
                dim1 = 'y';
                dim2 = 'x';
            } else {
                dim1 = 'x'
                dim2 = 'y';
            }
            let bounds;
            if (gridXYMarkers[dim1].length < 2) return;

            if (gridline.position[dim1] === gridXYMarkers[dim1][0]) {
                bounds = [gridXYMarkers[dim1][0], gridXYMarkers[dim1][1]];
            } else {
                bounds = [
                    gridXYMarkers[dim1][gridXYMarkers[dim1].length - 2],
                    gridXYMarkers[dim1][gridXYMarkers[dim1].length - 1]
                ];
            }
            for (let j = 0; j < gridXYMarkers[dim2].length - 1; j++) {
                let args = [
                    [gridXYMarkers[dim2][j], bounds[0]],
                    [gridXYMarkers[dim2][j + 1], bounds[1]]
                ]

                if (dim1 === 'x') {
                    args = args.map(el => el.reverse());
                }
                newGridlineBox = new GridlineBox(...args);
                chamberRealignmentData[currentImgIndex].gridlineBBoxes[newGridlineBox.id] = newGridlineBox;
            }
        }

        function addNotationModeToggleButtons() {
            let uiPane = document.getElementById('mask-annotation-mode-buttons');
            uiPane.classList.add('mask-button-set');
            document.getElementById('help-pane').style.height = '400px';

            let notationModeLabel = {
                id: 'notation-mode-label',
                innerHTML: 'Notation mode'
            };

            let gridEditButton = {
                id: 'grid-edit-button',
                innerHTML: 'Grid'
            };

            let freehandEditButton = {
                id: 'freehand-edit-button',
                innerHTML: 'Freehand'
            };

            maskNotationButtonGroup = new ButtonGroup(
                uiPane,
                notationModeLabel,
                gridEditButton,
                freehandEditButton,
                toggleMaskNotationMode
            );
        }

        function setUpMaskCreationInterface(opts = { draw: true }) {
            resetCurrentRealignmentMarkers();
            let helpPane = document.getElementById('help-pane');
            if (!helpPane) {
                $('#viewer').append('<div id=help-pane></div>');
                helpPane = document.getElementById('help-pane');
            }
            if (helpPane.style.display === 'none') {
                helpPane.style.display = 'inline-block';
            }
            $('#help-pane').empty();

            $('#help-pane').append('<p id=mask-edit-instructions>' +
                maskEditInstructions[
                chamberRealignmentData[currentImgIndex].customMode
                ])
            $('#help-pane').append('<div id=mask-annotation-mode-buttons></div')
            addNotationModeToggleButtons();
            $('#help-pane').append('<div id=mode-specific-buttons></div>');
            if (chamberRealignmentData[currentImgIndex].customMode === 'grid') {
                addGridNotationUI({ draw: opts.draw });
            } else {
                addFreehandNotationUI({ draw: opts.draw });
            }
            Object.keys(eggLayingRegions[currentImgIndex]).forEach(reg => {
                if (eggLayingRegions[currentImgIndex][reg].outline) {
                    eggLayingRegions[currentImgIndex][reg].outline.remove();
                    eggLayingRegions[currentImgIndex][reg].fill.remove();
                }
            });
            socket.emit('mask-list', { sid });
            addLockMaskButton();
            $('#help-pane').append('<hr>');

            if (maskNotationButtonGroup.selected.split('-')[0] !==
                chamberRealignmentData[currentImgIndex].customMode) {
                document.getElementById(
                    chamberRealignmentData[currentImgIndex].customMode +
                    '-edit-button'
                ).click();
            }
        }

        function addDropdownElement(dropdownEl, optionName, withPrefix = true) {
            let dropdownName = document.createElement('option');
            let displayedOptionName;
            if (withPrefix && optionName.length > 25) {
                displayedOptionName = `${optionName.slice(0, 23)}...`
            } else {
                displayedOptionName = optionName;
            }
            dropdownName.innerHTML = `${withPrefix ? 'Loaded mask: ' : ''}${displayedOptionName}`;
            dropdownName.value = optionName;
            dropdownEl.append(dropdownName);
        }

        function requestSavedMaskData() {
            socket.emit('load-custom-mask', {
                sid,
                maskName: document.getElementById('mask-list').value
            });
        }

        function displayMaskSetterAndReloader() {
            if (document.getElementById('mask-resetter-and-loader')) {
                return;
            }
            let newButtonGroup = document.createElement('div');
            newButtonGroup.classList.add('mask-button-set');
            newButtonGroup.id = 'mask-resetter-and-loader';
            let resetMasks = document.createElement('button');
            resetMasks.id = 'reset-masks';
            resetMasks.innerHTML = 'Revert to last saved version';
            resetMasks.setAttribute('disabled', true);
            resetMasks.onclick = requestSavedMaskData;
            let helpPane = document.getElementById('help-pane');
            newButtonGroup.appendChild(resetMasks);
            helpPane.appendChild(newButtonGroup);
            $('#mask-resetter-and-loader').append(dividerString());
        }

        function displayMaskList() {
            let dropdownMaskList;
            if (document.getElementById('mask-selector')) {
                dropdownMaskList = document.getElementById('mask-list');
                for (i = 0; i < dropdownMaskList.length; i++) {
                    if (dropdownMaskList.options[i].value == 'D') {
                        dropdownMaskList.remove(i);
                    }
                }
            } else {
                let buttonGroup = document.createElement('div');
                buttonGroup.classList.add('mask-button-set');
                buttonGroup.id = 'mask-selector'
                dropdownMaskList = document.createElement('select');
                dropdownMaskList.setAttribute('disabled', true);

                dropdownMaskList.setAttribute('id', 'mask-list');
                addDropdownElement(dropdownMaskList, 'Select existing mask', false);
                buttonGroup.appendChild(dropdownMaskList);
                let chosenMask = chamberRealignmentData[currentImgIndex].maskName;
                dropdownMaskList.onchange = requestSavedMaskData;
                document.getElementById('help-pane').appendChild(buttonGroup);
            }
            if (maskNames) {
                if (maskNames.length > 0) {
                    dropdownMaskList.removeAttribute('disabled');
                    maskNames.forEach(name => {
                        addDropdownElement(dropdownMaskList, name);
                    });
                }
                if (maskNames.includes(chamberRealignmentData[currentImgIndex].maskName)) {
                    document.getElementById('mask-list').value = chosenMask;
                }
            }
        }

        function chamberTypeManuallyUpdated() {
            return countingState !== countingStates.post &&
                hasAValue(chamberRealignmentData[currentImgIndex].type) &&
                chamberTypes[orderedImgNames[currentImgIndex]] !==
                chamberRealignmentData[currentImgIndex].type;
        }

        var setupErrorAnnotationButtonHandlers = function () {
            if (countingState === countingStates.pre) {
                document.getElementById('chamber-type-select').onchange = (evt) => {
                    if (evt.target.value == 'custom') {
                        clearAlignmentGuideHelpBox();
                        editMode = 'mask';
                        chamberRealignmentData[currentImgIndex] = {
                            file_name: chamberRealignmentData[currentImgIndex].file_name,
                            scaling: 1,
                            rotationAngle: 0,
                            imageTranslation: [0, 0],
                            type: evt.target.value,
                            maskBBoxes: {},
                            gridlineBBoxes: {},
                            regionsToIgnore: [],
                            maskGridlines: { horiz: {}, vert: {} },
                            customMode: 'grid'
                        };
                        setUpMaskCreationInterface({ draw: false });
                        addMaskSelectionButtons();
                        maskCopyUpdater = new PeriodicUpdater(
                            () => {
                                let reducedData = {};
                                reducedData = addGridlinesToSaveData(currentImgIndex, reducedData);
                                reducedData = addGridlineBoxesToSaveData(currentImgIndex, reducedData);
                                reducedData = addFreehandBoxesToSaveData(currentImgIndex, reducedData);
                                localStorage.setItem('customMask',
                                    JSON.stringify({
                                        ...{
                                            customMode: chamberRealignmentData[currentImgIndex].customMode
                                        },
                                        ...reducedData[currentImgIndex]
                                    })
                                );
                            }
                        )
                        if (!localStorage.getItem('customMask')) {
                            localStorage.setItem('customMask', JSON.stringify({
                                customMode: 'grid',
                                maskGridlines: {
                                    horiz: {},
                                    vert: {}
                                },
                                gridlineBBoxes: {},
                                maskBBoxes: {}
                            }));
                        } else {
                            let savedMask = JSON.parse(localStorage.getItem('customMask'));
                            loadFreehandMaskOnImage(savedMask);
                            loadGridMaskOnImage(savedMask, {
                                clearData: false,
                                convertToCanvas: true
                            });
                            chamberRealignmentData[currentImgIndex].customMode = savedMask.customMode;
                            if (savedMask.customMode === 'freehand') {
                                document.getElementById(`${savedMask.customMode}-edit-button`).click();
                            }
                            document.getElementById('reset-masks').setAttribute('disabled', true);
                        }

                        maskCopyUpdater.registerUpdate();
                        return;
                    }
                    if (evt.target.value == chamberTypes[orderedImgNames[currentImgIndex]]) {
                        chamberRealignmentData[currentImgIndex].type = evt.target.value;
                        delete chamberRealignmentData[currentImgIndex].nodes;
                        delete eggLayingRegions[currentImgIndex];
                        document.getElementById('help-pane').remove();
                    } else {
                        chamberRealignmentData[currentImgIndex] = {
                            type: evt.target.value,
                            rotationAngle: 0,
                            ignored: chamberRealignmentData[currentImgIndex].ignored,
                            file_name: chamberRealignmentData[currentImgIndex].file_name
                        };
                        updateRetryAnalysisButtonAppearance();
                    }
                    redrawCanvas();
                };
                if (countingState !== countingStates.pre) return;

                document.getElementById('ignore-img').onclick = () => {
                    let chamberTypeButton = document.getElementById('chamber-type-select');
                    let chamberButtonDisabled = chamberTypeButton.hasAttribute('disabled');
                    if (chamberButtonDisabled) {
                        chamberRealignmentData[currentImgIndex].ignored = false;
                        chamberTypeButton.removeAttribute('disabled');
                        eggLayingRegions[currentImgIndex].bad = false;
                        eggLayingRegions[currentImgIndex].text.remove();
                        delete eggLayingRegions[currentImgIndex].text;
                    }
                    else {
                        chamberRealignmentData[currentImgIndex].ignored = true;
                        chamberTypeButton.setAttribute('disabled', true);
                        chamberTypeButton.value = 'null';
                        resetCurrentRealignmentMarkers();
                        eggLayingRegions[currentImgIndex].bad = true;
                        eggLayingRegions[currentImgIndex].text = drawErrorText(
                            'ImageIgnoredException'
                        );
                    }
                    updateIgnoreButtonText();
                    updateRetryAnalysisButtonAppearance();
                };
            }
        }

        function drawErrorText(errorType) {
            let pointText = new paper.PointText(new paper.Point(paper.view.center.x,
                paper.view.center.y))
            pointText.content = errorMessages[errorType];
            pointText.justification = 'center';
            pointText.fillColor = 'red';
            pointText.fontSize = '40px';
            return pointText;
        }

        function setupCountEggsButton() {
            document.getElementById('retry-analysis-button').onclick = () => {
                let untriaged = indicesOfUntriagedImages();
                if (untriaged.length > 0) {
                    document.getElementById('mode-marker').innerHTML = 'Images can only be submitted if' +
                        ' each one has either been assigned a chamber type or marked as ignored.' +
                        ' <br>The images at the following indices still need attention:' +
                        ` ${untriaged.length > 1 ? `${untriaged.slice(0, -1).join(', ')
                            } and ${untriaged[untriaged.length - 1]}` : untriaged[0]}.`;
                    setTimeout(() => {
                        document.getElementById('mode-marker').innerHTML = '';
                    }, 3000);
                    return;
                }
                transformAlignmentGuidelinePoints();
                let keysToKeep = [
                    'ignored',
                    'bboxes',
                    'regionsToIgnore',
                    'nodes',
                    'rotationAngle',
                    'imageTranslation',
                    'scaling',
                    'type',
                    'file_name'
                ];
                let dataToSend = {
                    chamberData: reducePropsInInnerObjects(chamberRealignmentData, keysToKeep),
                    sid
                };
                countingState = countingStates.mid;
                input.setAttribute('disabled', true);
                inputLbl.style.color = colors.grey;
                $.ajax({
                    url: '/manual-recount',
                    type: "POST",
                    data: JSON.stringify(dataToSend),
                    contentType: "application/json",
                    success: function (data) {
                        console.log('Success!');
                    }
                });
                clearAllUpdates();
            }
        }

        function reducePropsInInnerObjects(objectofObjects, keysToKeep) {
            let reducedObj = {};
            Object.keys(objectofObjects).forEach(objKey => {
                reducedObj[objKey] = {}
                keysToKeep.forEach(k => {
                    if (!objectofObjects[objKey][k] &&
                        objectofObjects[objKey][k] !== 0) return;
                    reducedObj[objKey][k] = objectofObjects[objKey][k];
                })
            });
            return reducedObj;
        }

        function calcScalingFactor(rotationAngle = 0, index = currentImgIndex) {
            let wd = unscaledImgBounds[orderedImgNames[index]].width;
            let ht = unscaledImgBounds[orderedImgNames[index]].height;
            scalingFactor = Math.min(canvasHeight / (Math.abs(wd * Math.sin(rotationAngle)) + Math.abs(ht * Math.cos(rotationAngle))),
                canvasWidth / (Math.abs(wd * Math.cos(rotationAngle)) +
                    Math.abs(ht * Math.sin(rotationAngle))));
        }

        function transformAlignmentGuidelinePoints() {
            Object.keys(chamberRealignmentData).forEach(k => {
                if (chamberRealignmentData[k].ignored) {
                    return;
                }
                calcScalingFactor(imageUsesCustomMasks(k) ? 0 : rotationAngles[orderedImgNames[k]], k);
                calcPadding(imageUsesCustomMasks(k) ? 0 : rotationAngles[orderedImgNames[k]], k);

                if (chamberRealignmentData[k].imageTranslation) {
                    chamberRealignmentData[k].imageTranslation.forEach((el, i) => {
                        chamberRealignmentData[k].imageTranslation[i] = el / scalingFactor;
                    });
                }
                if (chamberRealignmentData[k].type === 'custom') {
                    if (chamberRealignmentData[k].customMode === 'grid') {
                        convertGridBoxSelectionsToBBoxes(k);
                    } else if (chamberRealignmentData[k].customMode === 'freehand') {
                        convertFreehandBoxSelectionsToBBoxes(k);
                    }
                    return;
                }
                if (!chamberRealignmentData[k].nodes &&
                    !chamberRealignmentData[k].bboxes) {
                    chamberRealignmentData[k].type = chamberTypes[
                        orderedImgNames[k]
                    ]
                    chamberRealignmentData[k].bboxes = [];
                    chamberRealignmentData[k].rotationAngle = rotationAngles[orderedImgNames[k]]
                    annotations[orderedImgNames[k]].forEach(region => {
                        chamberRealignmentData[k].bboxes.push(region.bbox);
                    });
                    return;
                }
                Object.keys(chamberRealignmentData[k].nodes).forEach(node => {
                    let pt = chamberRealignmentData[k].nodes[node];
                    chamberRealignmentData[k].nodes[node] = [
                        (pt[0] - leftPadding) / scalingFactor,
                        (pt[1] - upperPadding) / scalingFactor
                    ];
                });
            });

        }

        function setupCsvDownloadButton() {
            document.getElementById('download-csv').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target);
                let rowsColsCounts = collectRowColCountLayout();
                socket.emit('prepare-csv', {
                    time: Date.now(),
                    sid: sid,
                    editedCounts: collectEditedCounts(),
                    rowColLayout: rowsColsCounts.rowsCols,
                    orderedCounts: rowsColsCounts.orderedCounts
                });
            }
        }

        function setupImgDownloadButton() {
            document.getElementById('download-imgs').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target)
                let requestTs = Date.now();
                socket.emit('prepare-annot-imgs-zip', {
                    time: requestTs,
                    sid: sid,
                    editedCounts: collectEditedCounts()
                });

            }
        }

        function setupErrorReportButton() {
            document.getElementById('submit-error-report').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target);
                socket.emit('submit-error-report', {
                    editedCounts: collectEditedCounts(),
                    sid: sid,
                    user: window.localStorage.getItem('user')
                });
            }
        }

        var setButtonHandlers = function () {
            if (countingState !== countingStates.pre) {
                setupCsvDownloadButton();
                setupImgDownloadButton();
                setupErrorReportButton();
            }
            setupErrorAnnotationButtonHandlers();
            if (countingState === countingStates.pre) {
                setupCountEggsButton();
            }

            if (orderedImgNames.length === 1) {
                document.getElementById('prev-img').setAttribute('disabled', true);
                document.getElementById('next-img').setAttribute('disabled', true);
                return
            }
            document.getElementById('prev-img').onclick = (evt) => {
                let newImgIdx = currentImgIndex - 1;
                if (newImgIdx >= 0) {
                    shiftKeyDown = false;
                    previousImgIndex = currentImgIndex;
                    currentImgIndex = newImgIdx;
                    setChamberTypeSelector();
                    resetInputAmender();
                    setIgnoreSelector();
                    redrawCanvas();
                    if (newImgIdx == 0) {
                        document.getElementById('prev-img').setAttribute('disabled', true);
                    } else {
                        document.getElementById('prev-img').removeAttribute('disabled');
                    }
                    document.getElementById('next-img').removeAttribute('disabled');
                }
            }
            document.getElementById('next-img').onclick = (evt) => {
                let newImgIdx = currentImgIndex + 1;
                if (newImgIdx <= orderedImgNames.length) {
                    shiftKeyDown = false;
                    previousImgIndex = currentImgIndex;
                    currentImgIndex = newImgIdx;
                    setChamberTypeSelector();
                    resetInputAmender()
                    setIgnoreSelector();
                    redrawCanvas();
                    if (document.getElementById('next-img').disabled) {
                        document.getElementById('next-img').removeAttribute('disabled');
                    }
                    if (newImgIdx > 0) {
                        document.getElementById('prev-img').removeAttribute('disabled');
                    }
                }
                if (newImgIdx >= orderedImgNames.length - 1) {
                    document.getElementById('next-img').setAttribute('disabled', true);
                    document.getElementById('prev-img').removeAttribute('disabled');
                }
            }
        }

        function resetInputAmender() {
            if (inputAmender) {
                inputAmender.remove();
                inputAmender = null;
            }
        }

        var setChamberTypeSelector = function () {
            if (countingState !== countingStates.pre) {
                return;
            }
            if (chamberRealignmentData[currentImgIndex] &&
                !['', 'null', undefined].includes(
                    chamberRealignmentData[currentImgIndex].type)) {
                document.getElementById('chamber-type-select').value = chamberRealignmentData[currentImgIndex].type;
            } else if (chamberTypes[orderedImgNames[currentImgIndex]]
                && !['', 'null', undefined].includes(
                    chamberTypes[orderedImgNames[currentImgIndex]])) {
                document.getElementById('chamber-type-select').value = chamberTypes[orderedImgNames[currentImgIndex]];
            } else {
                document.getElementById('chamber-type-select').value = 'null';
            }

        }

        var updateIgnoreButtonText = function () {
            document.getElementById('ignore-img').innerText = `${document.getElementById(
                'chamber-type-select').hasAttribute('disabled') ? 'Uni' : 'I'}gnore image`;

        }

        var setIgnoreSelector = function () {
            if (countingState !== countingStates.pre) return;
            let chamberTypeButton = document.getElementById('chamber-type-select')
            if (!chamberRealignmentData[currentImgIndex] || !chamberRealignmentData[currentImgIndex].ignored) {
                chamberTypeButton.removeAttribute('disabled');
            }
            else if (chamberRealignmentData[currentImgIndex].ignored) {
                chamberTypeButton.setAttribute('disabled', true);
            }
            updateIgnoreButtonText();
        }

        function base64ToBlob(base64, mime) {
            mime = mime || '';
            var sliceSize = 1024;
            var byteChars = window.atob(base64);
            var byteArrays = [];

            for (var offset = 0, len = byteChars.length; offset < len; offset += sliceSize) {
                var slice = byteChars.slice(offset, offset + sliceSize);

                var byteNumbers = new Array(slice.length);
                for (var i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                var byteArray = new Uint8Array(byteNumbers);

                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, { type: mime });
        }

        function setHelpPaneTextIfNoMarkers(opts) {
            document.getElementById('help-pane').style.height = '300px';
            let helpText;
            if (opts.imageIgnored) {
                helpText = 'To run egg counting on this image, click "Unignore image."';
            } else if (opts.noChamberTypeSelected && !opts.chamberTypeDetected) {
                helpText = 'Please select a chamber type from the menu at left.';
            } else if (opts.chamberTypeDetected && opts.noChamberTypeSelected) {
                helpText = 'If the identified chamber type is incorrect, please select another from the menu at left.';
            }
            document.getElementById('help-pane').innerText = helpText;
        }

        var updateRealignmentGuide = function () {
            document.getElementById('help-pane').style.display = 'inline-block';
            if (chamberRealignmentData[currentImgIndex] &&
                chamberRealignmentData[currentImgIndex].type === 'custom'
            ) {
                setUpMaskCreationInterface();
                return;
            }
            $('#help-pane').empty();
            let noChamberTypeSelected = ['null', '', undefined].includes(
                chamberRealignmentData[currentImgIndex].type);
            let chamberTypeDetected = !!chamberTypes[orderedImgNames[currentImgIndex]];
            let imageIgnored = document.getElementById('chamber-type-select').hasAttribute('disabled');
            if (noChamberTypeSelected || imageIgnored) {
                setHelpPaneTextIfNoMarkers({ noChamberTypeSelected, imageIgnored, chamberTypeDetected })
                return;
            }
            document.getElementById('help-pane').style.display = 'none';
        }

        function updateHelpBoxElements(framePosition, fontSize) {
            alignmentHelpDialog.frame.position = framePosition;
            alignmentHelpDialog.text.fontSize = fontSize;
            alignmentHelpDialog.text.point = getHelpTextPos();
            let buttonBounds = getHelpButtonCorners();
            let centerPosition = [
                0.5 * (buttonBounds.ul.x + buttonBounds.br.x),
                0.5 * (buttonBounds.ul.y + buttonBounds.br.y)
            ]
            alignmentHelpDialog.button.position = new paper.Point(
                ...centerPosition
            );
            alignmentHelpDialog.hoverSensor.position = new paper.Point(
                ...centerPosition
            );
            resizeHelpExampleImage();
            alignmentHelpDialog.exampleText.point = getExampleHelpPos();
        }

        function bringHelpBoxElementsToFront() {
            alignmentHelpDialogElements.forEach(element => {
                alignmentHelpDialog[element].bringToFront();
            })
        }

        function helpBoxIsMaximized() {
            return alignmentHelpDialog.buttonText && (
                alignmentHelpDialog.buttonText.content.includes('Start') ||
                alignmentHelpDialog.buttonText.content.includes('Resume')
            )
        }

        function resizeAlignmentGuideHelpBox() {
            if (helpBoxIsMaximized()) {
                let horizLBound = backgroundRaster.position.x -
                    0.20 * backgroundRaster.bounds.width;
                let horizUBound = backgroundRaster.position.x +
                    0.49 * backgroundRaster.bounds.width;
                let newHorizPosition = 0.5 * (horizLBound + horizUBound);
                let vertLBound = backgroundRaster.position.y -
                    0.20 * backgroundRaster.bounds.height;
                let vertUBound = backgroundRaster.position.y +
                    0.49 * backgroundRaster.bounds.height;
                let newVertPosition = 0.5 * (vertLBound + vertUBound);
                alignmentHelpDialog.frame.bounds.width = horizUBound - horizLBound;
                alignmentHelpDialog.frame.bounds.height = vertUBound - vertLBound;
                updateHelpBoxElements(new paper.Point(
                    newHorizPosition, newVertPosition
                ), '10pt');
                updateHelpButtonText('Maximize example image');
            } else if (alignmentHelpDialog.buttonText.content.includes('Maximize')) {
                let boxBounds = calculateFullSizeHelpBoxBounds();
                alignmentHelpDialog.frame.bounds.width = boxBounds.br.x - boxBounds.ul.x;
                alignmentHelpDialog.frame.bounds.height = boxBounds.br.y - boxBounds.ul.y;
                updateHelpBoxElements(new paper.Point(
                    0.5 * (boxBounds.br.x + boxBounds.ul.x),
                    0.5 * (boxBounds.br.y + boxBounds.ul.y)), '15pt');
                updateHelpButtonText('Resume alignment');
            }
            bringHelpBoxElementsToFront();
            chamberRealignmentData[currentImgIndex].helpBoxMaximized = helpBoxIsMaximized();
        }

        function calculateFullSizeHelpBoxBounds() {
            let guideBoxPadding = { leftRight: 80, topBottom: 15 };
            let boxULCorner = new paper.Point(guideBoxPadding.leftRight,
                guideBoxPadding.topBottom);
            let boxBRCorner = new paper.Point(project.view.size.width - guideBoxPadding.leftRight,
                project.view.size.height - guideBoxPadding.topBottom);
            return { ul: boxULCorner, br: boxBRCorner };
        }

        function updateHelpButtonText(newText) {
            alignmentHelpDialog.buttonText.content = newText;
            alignmentHelpDialog.buttonText.point = new paper.Point(
                alignmentHelpDialog.button.position.x -
                0.5 * alignmentHelpDialog.buttonText.bounds.width,
                alignmentHelpDialog.button.position.y +
                0.3 * alignmentHelpDialog.buttonText.bounds.height
            );
        }

        function getHelpButtonCorners() {
            let buttonWidth = 200;
            let buttonXPos = alignmentHelpDialog.frame.position.x - 0.5 * buttonWidth;
            let buttonULCorner = new paper.Point(alignmentHelpDialog.frame.position.x - 0.5 * buttonWidth,
                alignmentHelpDialog.text.position.y + 40);
            let buttonBRCorner = new paper.Point(buttonULCorner.x + buttonWidth,
                buttonULCorner.y + 40)
            return { ul: buttonULCorner, br: buttonBRCorner };
        }

        function getExampleHelpPos() {
            return alignmentHelpDialog.exampleImage.position;
        }

        function getHelpTextPos() {
            let textXPos = alignmentHelpDialog.frame.position.x - 0.5 * alignmentHelpDialog.text.bounds.width // midpoint of the box minus half of width of the text.
            return new paper.Point(textXPos,
                40 + alignmentHelpDialog.frame.position.y -
                0.5 * alignmentHelpDialog.frame.bounds.height)
        }

        function resizeHelpExampleImage() {
            let allottedHt = alignmentHelpDialog.frame.position.y +
                + 0.5 * alignmentHelpDialog.frame.bounds.height - (
                    alignmentHelpDialog.button.position.y +
                    0.5 * alignmentHelpDialog.button.bounds.height
                );
            let allottedWidth = 0.95 * alignmentHelpDialog.frame.bounds.width;
            let egScaling = Math.min(0.95 * allottedHt / alignmentHelpDialog.exampleImage.height,
                allottedWidth / alignmentHelpDialog.exampleImage.width);
            if (alignmentHelpDialog.imgScaling) {
                alignmentHelpDialog.exampleImage.scale(1 / alignmentHelpDialog.imgScaling)
            }
            alignmentHelpDialog.imgScaling = egScaling;
            alignmentHelpDialog.exampleImage.scale(egScaling);
            alignmentHelpDialog.exampleImage.position = new paper.Point(
                alignmentHelpDialog.frame.position.x,
                alignmentHelpDialog.frame.position.y +
                0.5 * alignmentHelpDialog.frame.bounds.height - 0.5 * allottedHt
            );
        }

        function clearAlignmentGuideHelpBox() {
            alignmentHelpDialogElements.concat(['imgScaling']).forEach(
                componentType => {
                    if (alignmentHelpDialog[componentType]) {
                        if (alignmentHelpDialog[componentType].remove) {
                            alignmentHelpDialog[componentType].remove();
                        }
                        alignmentHelpDialog[componentType] = null;
                    }
                });
        }

        function drawAlignmentGuideHelpBox() {
            clearAlignmentGuideHelpBox();
            let boxBounds = calculateFullSizeHelpBoxBounds()
            alignmentHelpDialog.frame = new paper.Path.Rectangle(boxBounds.ul,
                boxBounds.br);
            alignmentHelpDialog.frame.strokeColor = 'black';
            alignmentHelpDialog.frame.strokeWidth = 3;
            alignmentHelpDialog.frame.fillColor = 'white';
            alignmentHelpDialog.text = new paper.PointText(new paper.Point(0, 0));
            alignmentHelpDialog.text.content = "Please drag the line endpoints on your" +
                " image so that the lines are positioned\nas shown in the example." +
                " Once the alignment looks good, you can count eggs.";
            alignmentHelpDialog.fontSize = 16;
            do {
                alignmentHelpDialog.fontSize -= 1;
                alignmentHelpDialog.text.fontSize = `${alignmentHelpDialog.fontSize}pt`;
                alignmentHelpDialog.text.point = getHelpTextPos();
            } while (!alignmentHelpDialog.text.isInside(alignmentHelpDialog.frame.bounds))
            alignmentHelpDialog.exampleText = new paper.PointText(new paper.Point(0, 0));
            alignmentHelpDialog.exampleText.content = 'example';
            alignmentHelpDialog.exampleText.fontSize = '15pt';
            alignmentHelpDialog.exampleText.fillColor = 'red';
            alignmentHelpDialog.exampleText.justification = 'center';
            let buttonBounds = getHelpButtonCorners();
            alignmentHelpDialog.button = new paper.Shape.Rectangle(
                buttonBounds.ul, buttonBounds.br);
            alignmentHelpDialog.button.radius = 5;
            alignmentHelpDialog.button.fillColor = '#7F9CCB';
            alignmentHelpDialog.button.strokeColor = 'black';
            alignmentHelpDialog.button.strokeWidth = 0.5;
            alignmentHelpDialog.buttonText = new PointText(new paper.Point(0, 0));
            alignmentHelpDialog.buttonText.fontSize = '10pt';
            updateHelpButtonText('Start alignment');
            alignmentHelpDialog.hoverSensor = new paper.Shape.Rectangle(
                buttonBounds.ul, buttonBounds.br
            );
            alignmentHelpDialog.hoverSensor.fillColor = 'black';
            alignmentHelpDialog.hoverSensor.opacity = 0;
            alignmentHelpDialog.hoverSensor.onMouseDown = () => {
                resizeAlignmentGuideHelpBox();
            }
            alignmentHelpDialog.hoverSensor.onMouseEnter = () => {
                alignmentHelpDialog.button.strokeWidth = 2;
            };
            alignmentHelpDialog.hoverSensor.onMouseLeave = () => {
                alignmentHelpDialog.button.strokeWidth = 0.5;
            };
            if (!alignmentHelpDialog.exampleImage) {
                alignmentHelpDialog.exampleImage = new paper.Raster('static/imgs/' +
                    chamberRealignmentData[currentImgIndex].type + '_chamber_lines.jpg');
                alignmentHelpDialog.exampleImage.onLoad = () => {
                    resizeHelpExampleImage();
                    alignmentHelpDialog.exampleText.point = getExampleHelpPos();
                }
            }
            if (chamberRealignmentData[currentImgIndex].helpBoxMaximized !== undefined
                && chamberRealignmentData[currentImgIndex].helpBoxMaximized === false) {
                resizeAlignmentGuideHelpBox();
            }
        }

        function resetCurrentRealignmentMarkers() {
            Object.keys(currentRealignmentMarkers.lines).forEach(l => {
                currentRealignmentMarkers.lines[l].remove();
            })
            Object.keys(currentRealignmentMarkers.circles).forEach(c => {
                currentRealignmentMarkers.circles[c].paperCirc.remove();
            })
            currentRealignmentMarkers = { lines: {}, circles: {} };
        }

        var drawChamberAlignmentMarkers = function () {
            if (document.getElementById('chamber-type-select').value === 'custom') {
                Object.keys(chamberRealignmentData[currentImgIndex].gridlineBBoxes).forEach(key => {
                    chamberRealignmentData[currentImgIndex].gridlineBBoxes[key].restoreRectPath(key);
                });
                Object.keys(chamberRealignmentData[currentImgIndex].maskGridlines).forEach(key => {
                    Object.keys(chamberRealignmentData[currentImgIndex].maskGridlines[key]).forEach(lineId => {
                        chamberRealignmentData[currentImgIndex].maskGridlines[key][lineId].restoreLinePath(lineId);
                    });
                });
                return;
            }
            if (!chamberRealignmentData[currentImgIndex].nodes) {
                chamberRealignmentData[currentImgIndex].nodes = {
                    end1: [leftPadding + 0.9 * backgroundRaster.bounds.width, upperPadding + 80],
                    middle: [leftPadding + 80, upperPadding + 80],
                    end2: [leftPadding + 80, upperPadding + 0.9 * backgroundRaster.bounds.height]
                }
            }
            let currentNodes = chamberRealignmentData[currentImgIndex].nodes;
            currentRealignmentMarkers.lines = {
                toEnd1:
                    new paper.Path.Line({
                        from: new paper.Point(currentNodes.end1),
                        to: new paper.Point(currentNodes.middle),
                        strokeColor: 'red',
                        strokeWidth: 2
                    }), toEnd2:
                    new paper.Path.Line({
                        from: new paper.Point(currentNodes.end2),
                        to: new paper.Point(currentNodes.middle),
                        strokeColor: 'red',
                        strokeWidth: 2
                    })
            };
            let eventHandlers = {
                onDrag: (circle) => {
                    if (helpBoxIsMaximized()) {
                        return false;
                    }
                    let lineDefaults = { strokeColor: 'red', strokeWidth: 2 };
                    if (circle.name === 'end1' || circle.name === 'middle') {
                        currentRealignmentMarkers.lines.toEnd1.remove();
                        currentRealignmentMarkers.lines.toEnd1 = new paper.Path.Line({
                            ...{
                                from: currentRealignmentMarkers.circles.middle.position,
                                to: currentRealignmentMarkers.circles.end1.position,
                            }, ...lineDefaults
                        });
                    }
                    if (circle.name === 'end2' || circle.name === 'middle') {
                        currentRealignmentMarkers.lines.toEnd2.remove();
                        currentRealignmentMarkers.lines.toEnd2 = new paper.Path.Line({
                            ...
                            {
                                from: currentRealignmentMarkers.circles.middle.position,
                                to: currentRealignmentMarkers.circles.end2.position,
                            }, ...lineDefaults
                        });
                    }
                },
                onEnter: () => {
                    if (helpBoxIsMaximized()) {
                        return false;
                    }
                },
                onLeave: null,
                onMouseUp: (circle) => {
                    if (helpBoxIsMaximized()) {
                        return false;
                    }

                    chamberRealignmentData[currentImgIndex].nodes[circle.name] = [
                        currentRealignmentMarkers.circles[circle.name].position.x,
                        currentRealignmentMarkers.circles[circle.name].position.y
                    ];
                }
            }
            Object.keys(currentNodes).forEach(node => {
                currentRealignmentMarkers.circles[node] =
                    new DraggableCircle(currentNodes[node], 'red', 6,
                        eventHandlers, node);
            });
            tempCursor = null;
            drawAlignmentGuideHelpBox();
        }

        function resetNavButtons() {
            if (currentImgIndex === 0) {
                document.getElementById('prev-img').setAttribute('disabled', true);
            } else if (currentImgIndex === orderedImgNames.length - 1) {
                document.getElementById('next-img').setAttribute('disabled', true);
            }
        }

        function initializeNavButtons() {
            currentImgIndex = 0;
            document.getElementById('prev-img').setAttribute('disabled', true);
            if (orderedImgNames.length > 1) {
                document.getElementById('next-img').removeAttribute('disabled');
            } else {
                document.getElementById('next-img').setAttribute('disabled', true);
            }
        }

        function drawEggOutlines(annotation, anchorBBox) {
            let eggOutlines = [];

            let mappedOutlines = annotation.outlines.map(
                outline => {
                    return outline.map(pt => {
                        return [anchorBBox[0] + pt[1] * combinedScale,
                        anchorBBox[1] + pt[0] * combinedScale]
                    })
                }
            )
            mappedOutlines.forEach(outline => {
                eggOutlines.push(new paper.Path({
                    segments: outline,
                    strokeColor: 'white',
                    closed: true,
                    strokeWidth: 0.20,
                    opacity: 0.8
                }));
            });
            return eggOutlines;
        }

        function drawRegionOutline(annotation) {
            let bbox = annotation.bbox;
            combinedScale = scalingFactor * (1 / zoomScaleImgToMask);
            let rescaledBBox = [];
            rescaledBBox.push((1 / zoomScaleImgToMask) * (
                bbox[0] - zoomScaleImgToMask * backgroundRaster.width / 2) +
                zoomScaleImgToMask * backgroundRaster.width / 2);
            rescaledBBox.push((1 / zoomScaleImgToMask) * (
                bbox[1] - zoomScaleImgToMask * backgroundRaster.height / 2) +
                zoomScaleImgToMask * backgroundRaster.height / 2);
            rescaledBBox[0] = rescaledBBox[0] * scalingFactor + leftPadding;
            rescaledBBox[1] = rescaledBBox[1] * scalingFactor + upperPadding;
            rescaledBBox.push(bbox[2] * combinedScale);
            rescaledBBox.push(bbox[3] * combinedScale);
            let rectangle = new paper.Rectangle(
                new paper.Point(rescaledBBox[0], rescaledBBox[1]),
                new paper.Point(rescaledBBox[0] + rescaledBBox[2],
                    rescaledBBox[1] + rescaledBBox[3]));
            let rectPath = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
            rectPath.strokeColor = colors.grey;
            if (backgroundRaster.intersects(rectPath)) {
                setUpTempRasterRect();
                let newRectPath = rectPath.intersect(tempRasterRect);
                rectPath.remove();
                tearDownTempRasterRect();
                rectPath = newRectPath;
            }
            let innerRect = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
            innerRect.fillColor = 'black';
            innerRect.opacity = 0;
            if (countingState !== countingStates.pre) {
                addHoverHandler(innerRect, currentImgIndex);
            }
            return { outline: rectPath, fill: innerRect, bbox: rescaledBBox }
        }

        function hasAValue(valueToCheck) {
            return !['', 'null', undefined].includes(valueToCheck);
        }

        function redrawCanvas(opts = {}) {
            let origNumErrors = numErrors;
            hasErrors = Object.keys(annotations).map((k) => {
                return 'error' in annotations[k];
            });
            hasModifiedTypes = Object.keys(annotations).map((k) => {
                let index = Object.keys(chamberRealignmentData).map(
                    crKey => {
                        return chamberRealignmentData[crKey].file_name;
                    }
                ).indexOf(k)

                return index > -1 &&
                    hasAValue(chamberRealignmentData[index].type) &&
                    chamberTypes[k] !== chamberRealignmentData[index].type;
            });
            numErrors = hasErrors.filter(Boolean).length;
            numModifications = hasModifiedTypes.filter(Boolean).length;

            if (numErrors + numModifications > 0 && countingState === countingStates.pre) {
                if (origNumErrors === 0) {
                    setupNavButtons();

                    if (numErrors > 0) {
                        displayImageAnalysisErrorMessage();
                        document.getElementById('retry-analysis-button').style.color = colors.lightGrey;
                    }

                    resetCurrentRealignmentMarkers();
                }
                if (!document.getElementById('help-pane')) {
                    $('#viewer').append('<div id=help-pane></div>');
                }
                if (!chamberRealignmentData[currentImgIndex]) {
                    chamberRealignmentData[currentImgIndex] = {
                        type: '',
                        file_name: orderedImgNames[currentImgIndex]
                    }
                }
            }

            canvasLoaded = false;
            if (opts.startAtBeginning === true) {
                initializeNavButtons();
            } else {
                resetNavButtons();
            }
            if (countingState !== countingStates.pre && !document.getElementById('download-csv')) {
                $('#updates').prepend('<div><button type=button id=download-csv>Download results</button></div>');
            }
            setButtonHandlers();

            setCurrentImgName()
            setChamberTypeSelector();
            if (backgroundRaster) {
                backgroundRaster.remove();
            }
            if (previousImgIndex !== null && eggLayingRegions[previousImgIndex]) {
                if (eggLayingRegions[previousImgIndex].bad) {
                    eggLayingRegions[previousImgIndex].text.remove();
                } else {
                    Object.keys(eggLayingRegions[previousImgIndex]).forEach(region => {
                        let attributeList = ['text', 'outline', 'fill'];
                        attributeList.forEach(attr => {
                            if (eggLayingRegions[previousImgIndex][region][attr]) {
                                eggLayingRegions[previousImgIndex][region][attr].remove();
                            }
                        });
                    });
                }
            }
            $('#updates').append('<img id=pic src="/uploads/' +
                `${sid}/${orderedImgNames[currentImgIndex]}?lastmod=${Date.now()}">`);
            let rotationAngle = rotationAngles[orderedImgNames[currentImgIndex]] || 0;
            paper.project.clear();
            backgroundRaster = new paper.Raster('pic');
            pic = document.getElementById('pic');
            backgroundRaster.on('mouseleave', () => {
                cursorOnCanvas = false;
            });
            backgroundRaster.on('mousemove', () => {
                cursorOnCanvas = true;
            });
            backgroundRaster.onLoad = () => {
                if (numErrors + numModifications > 0 && countingState === countingStates.pre) {
                    updateRealignmentGuide();
                }
                if (imageUsesCustomMasks() && countingState !== countingStates.pre) {
                    rotationAngle = 0;
                }

                if (imageUsesCustomMasks() && countingState === countingStates.pre) {
                    backgroundRaster.fitBounds(paper.view.viewSize);
                    backgroundRaster.position.x += chamberRealignmentData[
                        currentImgIndex].imageTranslation[0];
                    backgroundRaster.position.y += chamberRealignmentData[
                        currentImgIndex].imageTranslation[1];
                    backgroundRaster.scale(chamberRealignmentData[currentImgIndex].scaling);
                    if (rotationAngle) {
                        backgroundRaster.rotate(-rotationAngle * 180 / Math.PI)
                    }
                }

                if (!imageUsesCustomMasks() || countingState !== countingStates.pre) {
                    backgroundRaster.fitBounds(paper.view.viewSize);
                }
                calcScalingFactor(0);
                document.getElementById('pic').remove();
                $('#updates').append('<div id=paper-finished-loading hidden></div>')
                calcPadding(0);
                if ('error' in annotations[orderedImgNames[currentImgIndex]] ||
                    chamberRealignmentData[currentImgIndex].ignored ||
                    chamberTypeManuallyUpdated()
                ) {
                    let errorText = chamberRealignmentData[currentImgIndex].ignored ?
                        'ImageIgnoredException' : annotations[orderedImgNames[currentImgIndex]].error;
                    if (!errorText) {
                        errorText = 'ManualAlignment';
                    }
                    let pointText = drawErrorText(errorText);


                    eggLayingRegions[currentImgIndex] = { bad: true, text: pointText };
                    if (!chamberRealignmentData[currentImgIndex].ignored &&
                        !['', 'null'].includes(chamberRealignmentData[currentImgIndex].type)) {
                        drawChamberAlignmentMarkers();
                    }
                } else {
                    if (!eggLayingRegions[currentImgIndex]) {
                        eggLayingRegions[currentImgIndex] = {};
                        annotations[orderedImgNames[currentImgIndex]].forEach((annotation, i) => {
                            let pointText, eggOutlines, countToShow;
                            if (annotation.count >= 0) {
                                countToShow = annotation.count;
                            } else {
                                countToShow = '';
                            }
                            zoomScaleImgToMask = (chamberRealignmentData[currentImgIndex] &&
                                chamberRealignmentData[currentImgIndex].scaling) ?
                                chamberRealignmentData[currentImgIndex].scaling : 1;
                            let drawnRectangles = drawRegionOutline(annotation);
                            let rectPath = drawnRectangles.outline;
                            let innerRect = drawnRectangles.fill;
                            if (countingState !== countingStates.pre) {
                                let x = (1 / zoomScaleImgToMask) *
                                    (annotation.x - zoomScaleImgToMask * backgroundRaster.width / 2) +
                                    zoomScaleImgToMask * backgroundRaster.width / 2;
                                let y = (1 / zoomScaleImgToMask) *
                                    (annotation.y - zoomScaleImgToMask * backgroundRaster.height / 2) +
                                    zoomScaleImgToMask * backgroundRaster.height / 2;
                                x = x * scalingFactor + leftPadding;
                                y = y * scalingFactor + upperPadding;
                                let textOrigin = new paper.Point(x, y)
                                pointText = new paper.PointText(new paper.Point(x, y));
                                pointText.justification = 'center';
                                pointText.fillColor = 'black';
                                pointText.content = annotation.count;
                                pointText.fontSize = defaultFontSize;

                                eggOutlines = drawEggOutlines(annotation,
                                    drawnRectangles.bbox);
                            }
                            innerRect.bringToFront();
                            eggLayingRegions[currentImgIndex][innerRect.id] = {
                                outline: rectPath,
                                fill: innerRect,
                                text: pointText,
                                eggShapes: eggOutlines,
                                bboxIndex: i,
                                originalCount: countToShow.toString(),
                                beenEdited() {
                                    if (!this.text) {
                                        return false;
                                    }
                                    return this.originalCount !== this.text.content;
                                }
                            };
                            if (chamberRealignmentData[currentImgIndex] &&
                                chamberRealignmentData[currentImgIndex].rotationAngle) {
                                rotateBoxesAndOutlinesForCustomMask(innerRect.id)
                            }
                        });
                    } else {
                        console.log('current image index:', currentImgIndex)
                        console.log('there was already an entry in egg-laying regions.');
                        console.log(eggLayingRegions[currentImgIndex])
                        Object.keys(eggLayingRegions[currentImgIndex]).forEach((region, i) => {
                            // recreate the text
                            let reg = eggLayingRegions[currentImgIndex][region];
                            zoomScaleImgToMask = (chamberRealignmentData[currentImgIndex] &&
                                chamberRealignmentData[currentImgIndex].scaling) ?
                                chamberRealignmentData[currentImgIndex].scaling : 1;
                            // recreate the outline
                            let origOutline = reg.outline;
                            let annotation = annotations[orderedImgNames[currentImgIndex]][i];
                            let drawnRectangles = drawRegionOutline(annotation);
                            // recreate the inner fill
                            let origFill = reg.fill;
                            reg.outline = drawnRectangles.outline;
                            reg.outline.strokeColor = reg.beenEdited() ? colors.lightRed : colors.grey;
                            reg.fill = drawnRectangles.fill;


                            if (countingState !== countingStates.pre) {
                                console.log('redrawing a region after counting is complete');
                                if (reg.beenEdited()) {
                                    drawTextForEditedCount(reg, reg.text.content);
                                } else {
                                    let origText = reg.text;
                                    reg.text = new paper.PointText(new paper.Point(origText.point.x,
                                        origText.point.y));
                                    reg.text.content = origText.content;
                                    reg.text.justification = 'center';
                                    reg.text.fillColor = reg.beenEdited() ? colors.lightRed : 'black';
                                    reg.text.fontSize = origText.fontSize;
                                }
                                let origEggShapes = reg.eggShapes;
                                reg.eggShapes = drawEggOutlines(annotation, drawnRectangles.bbox);
                                addHoverHandler(reg.fill, currentImgIndex);
                            }
                            reg.fill.bringToFront();
                            eggLayingRegions[currentImgIndex][reg.fill.id] = {
                                centeredTextPosition: reg.centeredTextPosition,
                                outline: reg.outline,
                                fill: reg.fill,
                                text: reg.text,
                                textPredicted: reg.textPredicted,
                                eggShapes: reg.eggShapes,
                                bboxIndex: reg.bboxIndex,
                                originalCount: reg.originalCount,
                                beenEdited() {
                                    if (!this.text) {
                                        return false;
                                    }
                                    return this.originalCount !== this.text.content;
                                }
                            }
                            delete eggLayingRegions[currentImgIndex][origFill.id];
                            if (chamberRealignmentData[currentImgIndex] &&
                                chamberRealignmentData[currentImgIndex].rotationAngle) {
                                rotateBoxesAndOutlinesForCustomMask(reg.fill.id)
                            }
                        });
                    }
                }
                origCenter = paper.view.center;
                canvasLoaded = true;
            }
            document.activeElement.blur();
        }

        var drawTextForUneditedCount = (reg) => {
            let x, y;
            if (reg.centeredTextPosition) {
                x = reg.centeredTextPosition.x;
                y = reg.centeredTextPosition.y
            } else {
                x = reg.text.point.x;
                y = reg.text.point.y;
            }
            reg.text.remove();
            if (reg.textPredicted) {
                reg.textPredicted.remove();
            }
            reg.text = new paper.PointText(new paper.Point(x, y));
            reg.text.content = reg.originalCount;
            reg.text.justification = 'center';
            reg.text.fillColor = 'black';
            reg.text.fontSize = defaultFontSize;
        }

        var drawTextForEditedCount = (reg, value) => {
            if (!reg.centeredTextPosition) {
                reg.centeredTextPosition = reg.text.point;
            }
            let origText = reg.text;
            reg.text.remove();
            reg.text = new paper.PointText(new paper.Point(reg.centeredTextPosition.x, reg.centeredTextPosition.y - 10));
            reg.text.content = value;
            reg.text.justification = 'center';
            reg.text.fillColor = colors.lightRed;
            reg.text.fontSize = origText.fontSize;
            if (reg.textPredicted) {
                reg.textPredicted.remove();
            }
            reg.textPredicted = new paper.PointText(new paper.Point(reg.centeredTextPosition.x, reg.centeredTextPosition.y + 10));
            reg.textPredicted.content = reg.originalCount;
            reg.textPredicted.justification = 'center';
            reg.textPredicted.fillColor = 'black';
            reg.textPredicted.fontSize = origText.fontSize;
        };

        var addHoverHandler = function (path, index) {
            path.onMouseEnter = () => {
                if (inputAmender) {
                    return;
                }
                if (eggLayingRegions[index][path.id].beenEdited()) {
                    eggLayingRegions[index][path.id].outline.strokeWidth = 2;
                    return;
                }
                eggLayingRegions[index][path.id].text.fillColor = colors.lightRed;
                eggLayingRegions[index][path.id].outline.strokeColor = colors.lightRed;
            }
            path.onMouseLeave = () => {
                if (inputAmender) {
                    return;
                }
                eggLayingRegions[index][path.id].outline.strokeWidth = 1;
                if (eggLayingRegions[index][path.id].beenEdited()) {
                    return;
                }
                eggLayingRegions[index][path.id].text.fillColor = 'black';
                eggLayingRegions[index][path.id].outline.strokeColor = colors.grey;
            }
            path.onClick = (event) => {
                if (inputAmender ||
                    new Date().getTime() - lastMouseDownTime > 300 ||
                    lastCanvasMoveTime > lastMouseDownTime) {
                    return;
                }
                let viewer = document.getElementById('viewer')
                inputAmender = document.createElement('input');
                eggLayingRegions[index][path.id].text.opacity = 0;
                pathAmendId = path.id;
                inputAmender.type = 'text';
                inputAmender.setAttribute('class', 'live-count-editor');
                var viewportOffset = viewer.getBoundingClientRect();
                let text = eggLayingRegions[index][path.id].text;
                let fieldHeight = text.bounds.height * paper.view.zoom;
                let fieldWidth = text.bounds.width * paper.view.zoom;
                eggLayingRegions[index][path.id].outline.strokeWidth = 2;
                inputAmender.style = 'position: absolute; left:' +
                    ` ${viewer.offsetLeft + eggLayingRegions[index][path.id].outline.bounds.x}px; ` +
                    `top: ${viewer.offsetTop + eggLayingRegions[index][path.id].outline.bounds.y}px; ` +
                    `width: ${75 * paper.view.zoom}px;` +
                    `height: ${26 * paper.view.zoom}px;` +
                    `font-size: ${0.75 * text.fontSize * paper.view.zoom}px;`
                inputAmender.placeholder = 'e.g., 42';
                viewer.appendChild(inputAmender);
                inputAmender.focus();
                eggLayingRegions[index][path.id].text.fillColor = colors.lightRed;
                eggLayingRegions[index][path.id].outline.strokeColor = colors.lightRed;
                inputAmender.onkeydown = checkIfEnterKeyPressed
                inputAmender.oninput = amendEggCount;
            }
        }

        var checkIfEnterKeyPressed = function (event) {
            lastKeyPressed = event.code;
            if (!lastKeyPressed.startsWith('Digit') && !lastKeyPressed.startsWith('Key')) {
                amendEggCount(event, inputAmender.value);
            }
        }

        var amendEggCount = function (event, value = null) {
            if (lastKeyPressed === 'Escape') {
                let reg = eggLayingRegions[currentImgIndex][pathAmendId];
                reg.text.fillColor = reg.beenEdited() ? colors.lightRed : 'black';
                reg.outline.strokeColor = reg.beenEdited() ? colors.lightRed : colors.grey;
                reg.outline.strokeWidth = 1;
                reg.text.opacity = 1.0;
                inputAmender.remove();
                inputAmender = null;
                return;
            }
            let errorGrey = '#b99393';
            let okGrey = ' #acacac';
            if (!value) {
                value = this.value.toString()
            }
            if (lastKeyPressed === 'Enter') {
                if (isNormalInteger(value)) {
                    if (value == eggLayingRegions[currentImgIndex][pathAmendId].originalCount) {
                        idsWithEdits.delete(pathAmendId)
                        drawTextForUneditedCount(eggLayingRegions[currentImgIndex][pathAmendId]);
                    } else {
                        idsWithEdits.add(pathAmendId)
                        drawTextForEditedCount(eggLayingRegions[currentImgIndex][pathAmendId], value);
                    }
                    inputAmender.remove();
                    inputAmender = null;
                    if (idsWithEdits.size > 0) {
                        document.getElementById('submit-error-report').removeAttribute('hidden');
                    } else {
                        document.getElementById('submit-error-report').setAttribute('hidden', 'true');
                    }
                } else {
                    inputAmender.style.backgroundColor = errorGrey;
                }
            } else if (isNormalInteger(value)) {
                inputAmender.style.backgroundColor = okGrey;
            } else {
                inputAmender.style.backgroundColor = errorGrey;
            }
        }

        var dividerString = function () {
            return '<div class=divider></div>'
        }

        var buttonString = function (id, text, hidden = false) {
            let doms = [`<button id=${id} ${hidden ? 'hidden' : ''}>${text}</button>`]
            if (!hidden) {
                doms.push(dividerString());
            }
            return doms
        }

        var errorAnnotationButtons = function () {
            let allButtons = [{ id: 'ignore-img', text: 'Ignore image' }, {
                id: 'chamber-type-select', text: 'Chamber type: not set',
                selectOptions: [{ value: 'sixByFour', text: 'Chamber type: 6 rows x 4 cols' },
                { value: 'fiveByThree', text: 'Chamber type: 5 rows x 3 cols' },
                { value: 'opto', text: 'Chamber type: optogenetic' },
                { value: 'large', text: 'Chamber type: large' },
                { value: 'custom', text: 'Custom masks' }
                ]
            },
            { id: 'retry-analysis-button', text: 'Count eggs' }
            ];
            if (countingState !== countingStates.pre) {
                return allButtons.slice(2, 2);
            }
            return allButtons;
        }

        var analyzedImagesButtons = function () {
            userSelectOptions = [];
            {% for user in users %}
            userSelectOptions.push({ value: '{{user}}', text: 'User: {{user}}' })
            {% endfor %}
            let allButtons = [
                { id: 'download-imgs', text: 'Download annotated images', hidden: countingState === countingStates.pre },
                {
                    id: 'submit-error-report', text: 'Submit error report for all images',
                    hidden: true
                },
            ];
            if (countingState === countingStates.pre) {
                return allButtons.slice(1);
            }
            return allButtons;
        }

        var getContextSpecificButtons = function () {
            return errorAnnotationButtons().concat(analyzedImagesButtons());
        }

        var displayImageAnalysisErrorMessage = function () {
            document.getElementById('modal-1-close').removeAttribute('hidden');
            document.getElementById('modal-1-title').innerText = 'Image analysis error';
            document.getElementById('modal-1-message').innerText =
                `We were not able to detect the egg-laying regions in ${numErrors}` +
                ' of your images, but with your help, they can still be analyzed.' +
                ' After dismissing this message, any images with errors will be displayed' +
                ' in a tool allowing you to mark two boundary lines on the image which' +
                ' will allow it to be split into individual regions. Click X to continue.'
            document.getElementById('modalToggle').click();
        }

        function setupNavButtons() {
            if (document.getElementById('viewer-nav')) {
                document.getElementById('viewer-nav').remove();
            }
            $('#updates').prepend('<div id=viewer-nav></div>');
            const constant_buttons = [{ id: 'reset-view', text: 'Reset view' },
            {
                id: 'prev-img', text: 'Previous image',
            },
            { id: 'next-img', text: 'Next image' }];
            $('#viewer-nav').append('<div id=button-row></div>');
            constant_buttons.forEach(b => {
                let doms = buttonString(b.id, b.text, b.hidden);
                doms.forEach(d => {
                    $('#button-row').append(d);
                })
            });
            $('#reset-view').click(reposition);
            getContextSpecificButtons().forEach(b => {
                if (b.selectOptions) {
                    $('#button-row').append(`<select id=${b.id} ${b.hidden ? 'hidden' : ''}></select>`);
                    selectDOM = document.getElementById(b.id);
                    let opt = document.createElement('option');
                    opt.value = null;
                    opt.innerText = b.text;
                    selectDOM.append(opt);
                    b.selectOptions.forEach(so => {
                        opt = document.createElement('option');
                        opt.innerText = so.text;
                        opt.value = so.value;
                        selectDOM.appendChild(opt)
                    });
                    $('#button-row').append(dividerString());
                }
                else {
                    let doms = buttonString(b.id, b.text, b.hidden);
                    doms.forEach(d => {
                        $('#button-row').append(d);
                    })
                }
            });
        }

        function setupCanvas() {
            setupNavButtons();
            $('#viewer-nav').append('<div class=divider></div>');
            $('#updates').append('<br><div id=current-img-parent><p id=mode-marker></p><p id=current-img></p>');
            setCurrentImgName()
            $('#updates').append('<div id=viewer></div>')
            $('#viewer').append('<canvas keepalive=true id=detectionResults></canvas>');
            canvas = document.getElementById('detectionResults');
            paper.install(window);
            paper.setup(canvas);
            paper.view.viewSize = new paper.Size(canvasWidth, canvasHeight);
            redrawCanvas({
                startAtBeginning: true,
            });
            setPointerHandlers();
            setDragHandler();
        }

        function checkForAnnotatedCustomMaskImages(index, untriaged) {
            if (!imageUsesCustomMasks()) return untriaged;
            if (!imageUsesGridBoxes()) {
                if (!chamberRealignmentData[index].maskBBoxes ||
                    Object.keys(chamberRealignmentData[index].maskBBoxes).length === 0) {
                    untriaged.push(index + 1);
                }
            } else if (!chamberRealignmentData[index].gridlineBBoxes ||
                !Object.keys(chamberRealignmentData[index].gridlineBBoxes).some(
                    el => {
                        return chamberRealignmentData[index].gridlineBBoxes[el].selected;
                    })) {
                untriaged.push(index + 1);
            }
            return untriaged;
        }

        function indicesOfUntriagedImages() {
            let untriaged = []
            for (let index = 0; index < orderedImgNames.length; index++) {
                if (!hasErrors[index]) {
                    continue;
                }
                if (!chamberRealignmentData[index]) {
                    untriaged.push(index + 1)
                    continue;
                }
                if (checkForAnnotatedCustomMaskImages(index, untriaged)) {
                    continue;
                }
                else if (!(chamberRealignmentData[index].ignored ||
                    !['', 'null'].includes(chamberRealignmentData[index].type))) {
                    untriaged.push(index + 1);
                }
            }
            return untriaged;
        }

        var zoomInAndOut = e => {
            if (!maskLocked() && (!e.shiftKey || inputAmender)) {
                return;
            }
            e.preventDefault();
            if (lastScrollTime && Date.now() - lastScrollTime < 250) {
                return;
            }
            lastScrollTime = Date.now();
            if (maskLocked()) {
                transformImageOnly(e)
                return;
            }
            let view = paper.view;
            let viewPosition = view.viewToProject(
                new paper.Point(e.offsetX, e.offsetY)
            );

            let transform = changeZoom(e.deltaY, viewPosition);
            if (paper.view.zoom <= 1 && transform.zoom <= 1) {
                return;
            }
            if (transform.zoom < 10 && transform.zoom > 0.01) {
                newScale = 1 / transform.zoom;
                paper.view.zoom = transform.zoom;
                paper.view.center = view.center.add(transform.offset);
            }
        }

        var changeZoom = (delta, p) => {
            let oldZoom = paper.view.zoom;
            let c = paper.view.center;
            let factor = 1 + zoom;

            let zoomTemp = delta < 0 ? oldZoom * factor : oldZoom / factor;
            let beta = oldZoom / zoomTemp;
            let pc = p.subtract(c);
            let a = p.subtract(pc.multiply(beta)).subtract(c);

            return { zoom: zoomTemp, offset: a };
        }

        function setEggOutlineOpacity(opacity) {
            if (countingState === countingStates.pre) {
                return;
            }
            Object.keys(eggLayingRegions[currentImgIndex]).forEach(region => {
                eggLayingRegions[currentImgIndex][region].eggShapes.forEach(outline => {
                    outline.opacity = opacity;
                });
            });
        }

        function hideEggOutlines() {
            setEggOutlineOpacity(0);
        }

        function showEggOutlines() {
            setEggOutlineOpacity(0.8);
        }

        var setPointerHandlers = function () {
            canvas.addEventListener('wheel', zoomInAndOut, { passive: false });
            paper.view.on('mousedown', function (e) {
                pointerDown = true;
                timeDownUp = new Date().getTime();
                lastMouseDownTime = timeDownUp;
                dragStart = true;
            });
            paper.view.on('mouseup', function () {
                pointerDown = false;
                timeDownUp = new Date().getTime();
                dragStart = false;
            });
        }

        function moveBBoxCircles(rect) {
            for (var i = 0; i < rect.data.corners.length; i++) {
                rect.data.corners[i].position = rect.segments[i].point;
            }
        }

        function adjustBBox(e, rect) {
            if (rect.data.state === 'moving') {
                rect.position = rect.position.add(e.point).subtract(e.lastPoint);
                rect.data.innerRect.position = rect.position;

            } else if (rect.data.state === 'resizing') {
                let cornerVec = e.point.subtract(rect.bounds.center);
                let newBounds;
                if (cornerVec.x > 0 && cornerVec.y > 0) { // BR
                    newBounds = new paper.Rectangle(
                        rect.bounds.topLeft,
                        e.point
                    )
                } else if (cornerVec.x > 0 && cornerVec.y <= 0) { // TR
                    newBounds = new paper.Rectangle(
                        new paper.Point(rect.bounds.topLeft.x,
                            e.point.y),
                        new paper.Point(e.point.x,
                            rect.bounds.bottomRight.y
                        )
                    );
                } else if (cornerVec.x <= 0 && cornerVec.y <= 0) { // TL
                    newBounds = new paper.Rectangle(
                        e.point, rect.bounds.bottomRight
                    );
                } else { // BL
                    newBounds = new paper.Rectangle(
                        new paper.Point(e.point.x,
                            rect.bounds.topLeft.y),
                        new paper.Point(rect.bounds.bottomRight.x,
                            e.point.y)
                    );
                }
                rect.bounds = newBounds;
                rect.data.innerRect.bounds = newBounds;
            }

            moveBBoxCircles(rect);
        }

        function updateGridlineForDeletion() {
            if (overlappingExistingGridline && overlappingExistingGridline.id &&
                chamberRealignmentData[currentImgIndex].maskGridlines[
                overlappingExistingGridline.orientation
                ][
                overlappingExistingGridline.id
                ]) {
                chamberRealignmentData[currentImgIndex].
                    maskGridlines[
                    overlappingExistingGridline.orientation
                ][overlappingExistingGridline.id].linePath.
                    strokeColor = shiftKeyDown ? 'red' : 'black';
            }
        }

        function updateBBoxOutlineForDeletion() {
            if (!currentMaskBBox) return;
            let myBox = chamberRealignmentData[
                currentImgIndex
            ].maskBBoxes[currentMaskBBox];
            if (shiftKeyDown) {
                myBox.strokeColor = 'red';
                myBox.data.state = 'delete';
            } else {
                myBox.strokeColor = colors.grey;
            }
        }

        function createMaskBBox(bounds, opts = { redraw: false }) {
            let maskBounds = {
                from: bounds[0],
                to: bounds[1]
            }
            let newRect = new paper.Path.Rectangle(
                {
                    ...maskBounds,
                    strokeColor: colors.grey
                });
            let innerRect = new paper.Path.Rectangle(
                {
                    ...maskBounds,
                    strokeColor: 'black',
                    fillColor: 'black',
                    opacity: 0
                }
            )
            innerRect.data.parent = newRect.id;
            innerRect.onClick = (e) => {
                let myBox = chamberRealignmentData[currentImgIndex].maskBBoxes[e.target.data.parent];
                if (myBox.data.state === 'delete') {
                    if (lastCanvasMoveTime - lastMouseDownTime > 0) {
                        return;
                    }
                    myBox.data.corners.forEach(corner => {
                        corner.remove();
                    });
                    myBox.data.innerRect.remove();
                    myBox.remove();
                    delete myBox.data.innerRect;
                    currentMaskBBox = null;
                    delete chamberRealignmentData[currentImgIndex].maskBBoxes[e.target.data.parent];
                    updateRetryAnalysisButtonAppearance();
                    maskCopyUpdater.registerUpdate();
                }
            }
            innerRect.onMouseMove = (e) => {
                let myBox = chamberRealignmentData[currentImgIndex].maskBBoxes[e.target.data.parent];
                if (myBox.data.state === 'resizing'
                    || pointerDown) {
                    return;
                }
                if (shiftKeyDown) {
                    myBox.data.state = 'delete';
                    myBox.strokeColor = 'red'

                } else {
                    myBox.data.state = 'moving';
                    myBox.strokeColor = 'black';
                }
                currentMaskBBox = innerRect.data.parent;
            }
            innerRect.onMouseLeave = (e) => {
                if (!chamberRealignmentData[currentImgIndex].maskBBoxes[e.target.data.parent]) {
                    return;
                }
                if (pointerDown) {
                    return;
                }
                currentMaskBBox = null;
                chamberRealignmentData[currentImgIndex].maskBBoxes[e.target.data.parent].strokeColor = colors.grey;
            }
            currentMaskBBox = newRect.id;
            newRect.data.state = null;

            newRect.data.corners = [];
            newRect.data.innerRect = innerRect;
            newRect.segments.forEach(function (segment, i) {
                var circle = new paper.Path.Circle({
                    center: segment.point,
                    fillColor: colors.grey,
                    radius: 3
                });
                circle.data.parent = newRect.id;
                newRect.data.corners.push(circle);
            });

            newRect.data.corners.forEach(circle => {
                circle.onMouseMove = () => {
                    if (circle.bounds.width === 6) {
                        circle.scale(2);
                    }
                    circle.fillColor = 'black';
                };
                circle.onMouseEnter = () => {
                    if (pointerDown) {
                        return;
                    }
                    if (circle.bounds.width === 6) {
                        circle.scale(2);
                    }
                    circle.fillColor = 'black';
                    chamberRealignmentData[currentImgIndex].maskBBoxes[circle.data.parent].data.state = 'resizing';
                    currentMaskBBox = circle.data.parent;
                };
                circle.onMouseLeave = () => {
                    if (circle.bounds.width === 12) {
                        circle.scale(0.5);
                    }
                    circle.fillColor = colors.grey;
                    if (pointerDown) {
                        return;
                    }
                    chamberRealignmentData[currentImgIndex].maskBBoxes[circle.data.parent].data.state = null;
                    currentMaskBBox = null;
                }
            });

            if (!opts.redraw) {
                newRect.data.state = 'resizing';
            }
            newRect.data.bounds = newRect.bounds.clone();
            newRect.data.isNew = true;
            chamberRealignmentData[currentImgIndex].maskBBoxes[newRect.id] = newRect;
        }

        function createOrAdjustMaskBBox(evt) {
            if (currentMaskBBox) {
                adjustBBox(evt, chamberRealignmentData[
                    currentImgIndex].maskBBoxes[currentMaskBBox]);
                return;
            }
            createMaskBBox([[evt.downPoint.x - 2, evt.downPoint.y - 2],
            [evt.point.x, evt.point.y]
            ]);
            updateRetryAnalysisButtonAppearance();
        }

        var setDragHandler = () => {
            var toolPan = new paper.Tool();
            toolPan.onMouseMove = function (evt) {
                addGridNotationCursor(evt);
            }
            toolPan.onMouseDown = function (evt) {
                addGridlineNotation(evt);
            }
            toolPan.onMouseDrag = function (evt) {
                if (maskLocked()) {
                    transformImageOnly(evt);
                    return;
                }
                if (editMode === 'mask' &&
                    maskNotationButtonGroup.selected === 'freehand-edit-button'
                    && !shiftKeyDown) {
                    createOrAdjustMaskBBox(evt);
                    maskCopyUpdater.registerUpdate();
                    return;
                }

                if (inputAmender || shapeBeingDragged) {
                    return;
                }
                var timeMove = new Date().getTime();
                if (timeMove > timeDownUp) {
                    if (dragStart) {
                        var offset = new paper.Point(evt.downPoint.x - evt.point.x,
                            evt.downPoint.y - evt.point.y);
                        let new_center = paper.view.center.add(offset);
                        paper.view.setCenter(new_center);
                        lastCanvasMoveTime = new Date().getTime();
                    }
                } else {
                    timeDownUp = null;
                }
            };
        }

        function reposition() {
            paper.view.zoom = 1;
            paper.view.center = origCenter;
            dragStart = false;
        }
    </script>

    <div class="modal" id="modal-1" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container w-90 w-40-ns" id='egg-flagger-div' role="dialog" aria-modal="true"
                aria-labelledby="modal-1-title">
                <header class="modal__header">
                    <h3 id="modal-1-title" class="modal__title">
                        Session expired
                        </h2>
                        <button id=modal-1-close hidden aria-label="Close modal" data-micromodal-close></button>
                </header>
                <div id="modal-1-message">
                    <p>The connection to the server has been lost; please refresh the page to continue.</p>
                </div>
            </div>
        </div>
    </div>
    <div id="page-mask"></div>
    <script>
        MicroModal.init();
    </script>
</body>