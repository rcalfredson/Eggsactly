<!doctype html>

<head>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/main.css') }}">
    <style>
        body {
            display: none
        }
    </style>
    <script src="https://cdn.socket.io/socket.io-3.0.1.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.7/paper-full.js"></script>
    <script src="../static/js/micromodal.min.js"></script>
    <title>Egg Counting</title>
</head>

<body>
    <script type="text/javascript">
        const socket = io();
        function rgb(r, g, b) {
            return "rgb(" + r + "," + g + "," + b + ")";
        }
        const colors = {
            grey: '#313036',
            red: '#fc2c03',
            lightGrey: rgb(115, 109, 125)
        };
        const errorMessages = {
            ImageAnalysisException: 'Image could not be analyzed.',
            CUDAMemoryException: 'Error: system ran out of resources.'
        }
        const defaultFontSize = 17;
        let sid;
        let input, inputs, inputDiv, inputLbl, inputReset, preview;
        let inputAmender;
        let inputAmenderNormalBckgnd;
        let lastKeyPressed;
        let pathAmendId;
        let filesToUpload = {};
        let annotations = {};
        let orderedImgNames = [];
        let eggLayingRegions = [];
        let imgUniqueNames = {};
        let rotationAngles = {};
        let idsByOrigImgName = {};
        let lastPongTime;
        let numFailedPings = 0;
        let hasErrors;
        let numErrors = 0;
        let chamberRealignmentData = {};
        let currentRealignmentMarkers = { lines: {}, circles: {} }
        let draggingRealignmentMarker = false;
        let selectDOM;
        let zoom = 1.0;
        let idsWithEdits = new Set();
        let lastScrollTime;
        let canvas;
        let canvasLoaded = false;
        let canvasWidth = Math.min(1300, window.innerWidth),
            canvasHeight = Math.min(800, window.innerHeight);
        let upperPadding, leftPadding;
        let scalingFactor;
        let pointerDown = false;
        let dragStart = false;
        let timeDownUp;
        let origCenter;
        let currentImgIndex = 0;
        let previousImgIndex;
        let backgroundRaster, pic;

        function isNormalInteger(str) {
            var n = Math.floor(Number(str));
            return n !== Infinity && String(n) === str && n >= 0;
        }

        function fileNameAndExt(str) {
            var file = str.split('/').pop();
            return [file.substr(0, file.lastIndexOf('.')), file.substr(file.lastIndexOf('.') + 1, file.length)]
        }

        function makeid(length, existing_ids = []) {
            var result = '';
            do {
                var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                var charactersLength = characters.length;
                for (var i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * charactersLength));
                }
            } while (existing_ids.indexOf(result) > 0)
            return result;
        }
    </script>
    <form id=notice><label style="background-color: rgb(252, 226, 113);">Please note: the page has changed recently. If
            this box overlaps with the text below it, or if any of the buttons don't have rounded edges and black
            borders, then some features might not have loaded; a complete refresh of the page should resolve this (on
            Mac, use
            Command-Option-R).</label></form>
    <label for="img-upload-1">Upload one or more egg-counting images<br>
        <span style="font-size: small; padding-left: 15px;">
            Note: hold down Ctrl key to select multiple files.
        </span>
    </label>
    <form id=img-form method=post enctype="multipart/form-data">
        <div id=img-inputs>
            <label id="img-upload-lbl" for="img-upload-1">Choose images to upload</label>
            <button hidden id=img-upload-reset type="button">Reset</button>
            <input class=img-upload type=file multiple="multiple" id="img-upload-1" name="img-upload-1">
        </div>
        <div class="preview">
            <p>No files currently selected for upload.</p>
        </div>
        <div>
            <button disabled id='img-upload-btn' type=button>Upload</button>
        </div>
    </form>
    <div id=updates>
        <div id=updates-by-image></div>
    </div>
    <button id="modalToggle" hidden data-micromodal-trigger="modal-1"></button>
    <script type="text/javascript">
        const fileTypes = [
            "image/apng",
            "image/bmp",
            "image/gif",
            "image/jpeg",
            "image/pjpeg",
            "image/png",
            "image/svg+xml",
            "image/tiff",
            "image/webp",
            "image/x-icon"
        ];

        function validFileType(file) {
            return fileTypes.includes(file.type);
        }

        function resetAllVariables() {
            pathAmendId = null;
            inputAmender = null;
            annotations = {};
            orderedImgNames = [];
            eggLayingRegions = [];
            zoom = 1.0;
            idsWithEdits = new Set();
            currentImgIndex = 0;
            previousImgIndex = null;
        }

        function clearAllUpdates() {
            $('#updates').empty();
            let tempDiv = document.createElement('div');
            tempDiv.setAttribute('id', 'updates-by-image');
            document.getElementById('updates').append(tempDiv);
        }

        $(function () {
            $('#img-upload-btn').click(function () {
                $(this).prop('disabled', true);
                resetAllVariables();
                var form_data = new FormData();
                Object.keys(filesToUpload).forEach((fileName) => {
                    form_data.append(fileName, filesToUpload[fileName]);
                })
                form_data.append('sid', sid);

                $.ajax({
                    type: 'POST',
                    url: '/upload',
                    data: form_data,
                    contentType: false,
                    cache: false,
                    processData: false,
                    success: function (data) {
                        console.log('Success!');
                    },
                });
            });
        });

        $(document).ready(() => {
            $("body").fadeIn(200);
            document.getElementById('page-mask').style.display = 'none';
            document.getElementById('modal-1').removeAttribute('style');
            socket.on('counting-progress', (msg) => {
                if (msg.overwrite) {
                    let elementToOverwrite = document.getElementById('replaceable-counting-msg');
                    if (elementToOverwrite) {
                        elementToOverwrite.innerText = msg.data;
                    }
                    else {
                        let newPara = document.createElement('p');
                        newPara.setAttribute('id', 'replaceable-counting-msg');
                        newPara.innerText = msg.data;
                        document.getElementById('updates-by-image').appendChild(newPara);
                    }
                    return;
                }
                $('#updates-by-image').append('<p>' + msg.data + '</p>')
            });
            socket.on('counting-error', (msg) => {
                $('#updates-by-image').append(`<p style="color: red">${msg.data}</p>`);
                orderedImgNames.push(msg.filename);
                annotations[msg.filename] = { 'error': msg.error_type }
            })
            socket.on('counting-done', (msg) => {
                $('#updates').append('<div><button type=button id=download-csv>Download results</button></div>');
                setupCanvas(msg.is_retry);
                document.getElementById('img-upload-btn').removeAttribute('disabled');
            });
            socket.on('counting-csv', (msg) => {
                $('#updates').append(`<form id=csv-retrieve hidden action=/csvResults/${msg.data}><input hidden value='Download results' type=submit>` +
                    '</input></form>');
                document.getElementById('csv-retrieve').submit();
                document.getElementById('csv-retrieve').remove();
                document.getElementById('download-csv').removeAttribute('disabled');
                clearInterval(document.getElementById('download-csv').loadingInterval);
            });
            socket.on('counting-annotations', (msg) => {
                annotations[msg.filename] = JSON.parse(msg.data);
                if (!msg.index) {
                    orderedImgNames.push(msg.filename)
                } else {
                    eggLayingRegions[msg.index].text.remove();
                    delete eggLayingRegions[msg.index];
                    rotationAngles[msg.filename] = msg.rotationAngle;
                }
            });
            socket.on('clear-all', () => {
                if (!!document.getElementById('updates')) {
                    clearAllUpdates();
                }
                annotations = {};
                orderedImgNames = [];
            });
            socket.on('clear-display', () => {
                $('#updates-by-image').empty();
            });
            socket.on('report-ready', () => {
                let el = document.getElementById('submit-error-report')
                el.removeAttribute('disabled');
                el.innerText = 'Submitted!';
                setTimeout(() => {
                    el.innerText = 'Submit error report for all images';
                }, 2500)
                clearInterval(el.loadingInterval);
            });
            socket.on('zip-annots-ready', (msg) => {
                $('#updates').append(`<form hidden id=annot-retrieve action=/annot-img/${msg.time}><input id=annot-retrieve-input hidden id= value='Download results' type=submit>` +
                    '</input></form>')
                document.getElementById('annot-retrieve').submit();
                document.getElementById('annot-retrieve').remove();
                document.getElementById('download-imgs').innerText = 'Download annotated images';
                document.getElementById('download-imgs').removeAttribute('disabled');
                clearInterval(document.getElementById('download-imgs').loadingInterval)
            });
            socket.on('sid-from-server', (msg) => {
                if (!sid) {
                    sid = msg.sid;
                    setupPings();
                }
            });

            socket.on('pong', () => {
                lastPongTime = Date.now();
            })
            setUpFileUploadDialog();
        });

        var setupPings = function () {
            setInterval(() => {
                socket.emit('ping', {
                    sid: sid
                });
                setTimeout(() => {
                    if (!lastPongTime || Date.now() - lastPongTime >= 5000) {
                        numFailedPings += 1;
                    } else if (lastPongTime && Date.now() - lastPongTime < 5000) {
                        numFailedPings = 0;
                    }
                    if (numFailedPings >= 2) {
                        document.getElementById('modal-1-close').setAttribute('hidden', true);
                        document.getElementById('modal-1-title').innerText = "Session expired";
                        document.getElementById('modal-1-message').innerText =
                            'The connection to the server has been lost; please refresh the page to continue.';
                        document.getElementById('modalToggle').click();
                    }
                }, 3000)
            }, 5000)
        }

        var setUpFileUploadDialog = function () {
            input = document.getElementById('img-upload-1');
            inputLbl = document.getElementById('img-upload-lbl');
            inputDiv = document.getElementById('img-inputs');
            inputReset = document.getElementById('img-upload-reset')
            preview = document.querySelector('.preview');
            input.addEventListener('change', updateImageDisplay);
            inputReset.onclick = handleResetClick;
        }

        var handleResetClick = function () {
            input.value = "";

            imgUniqueNames = [];
            idsByOrigImgName = {};
            filesToUpload = {};
            updateImageDisplay();
            inputReset.setAttribute('hidden', true);
            inputLbl.innerText = 'Choose images to upload';
            document.getElementById('img-upload-btn').setAttribute('disabled', 'true');
        };

        function updateImageDisplay() {
            while (preview.firstChild) {
                preview.removeChild(preview.firstChild);
            }
            let imgInputs = document.getElementsByClassName('img-upload');
            Array.prototype.forEach.call(input.files, (file) => {
                let id;
                if (file.name in idsByOrigImgName) {
                    id = makeid(3, idsByOrigImgName[file.name])
                } else {
                    id = ''
                }

                let filenameParts = fileNameAndExt(file.name);
                let imgUniqueName = `${filenameParts[0]}${id.length
                    > 0 ? `_${id}` : ''}.${filenameParts[1]}`
                if (file.name in idsByOrigImgName) {
                    idsByOrigImgName[file.name].push(imgUniqueName)
                } else {
                    idsByOrigImgName[file.name] = [imgUniqueName]
                }
                filesToUpload[imgUniqueName] = file
            });
            input.value = "";
            inputLbl.innerText = "Select more images";
            inputReset.removeAttribute('hidden');
            let curFiles = [];
            let inputMapping = []
            if (Object.keys(filesToUpload).length === 0) {
                const para = document.createElement('p');
                para.textContent = 'No files currently selected for upload';
                preview.appendChild(para);
            } else {
                document.getElementById('img-upload-btn').removeAttribute('disabled');
                const list = document.createElement('ol');
                preview.appendChild(list);

                Object.keys(filesToUpload).forEach((file, i) => {
                    const listItem = document.createElement('li');
                    const para = document.createElement('p');
                    const xDiv = document.createElement('div')
                    xDiv.setAttribute('class', 'close-button');
                    xDiv.setAttribute('id', `close-${i}`)
                    xDiv.assocImg = file;
                    const xStroke1 = document.createElement('div');
                    xStroke1.setAttribute('class', 'close-button-stroke1');
                    xStroke1.setAttribute('id', `close-stroke1-${i}`);
                    const xStroke2 = document.createElement('div');
                    xStroke2.setAttribute('class', 'close-button-stroke2');
                    xStroke2.setAttribute('id', `close-stroke2-${i}`);
                    xStroke1.appendChild(xStroke2);
                    xDiv.appendChild(xStroke1);
                    listItem.append(xDiv);
                    xDiv.onclick = (evt) => {
                        let splitId = evt.target.id.split('-');
                        let index = parseInt(splitId[splitId.length - 1]);
                        let imgKey = document.getElementById(`close-${index}`).assocImg;
                        idsByOrigImgName[filesToUpload[imgKey].name].splice(idsByOrigImgName[filesToUpload[imgKey].name].indexOf(imgKey), 1);
                        if (idsByOrigImgName[filesToUpload[imgKey].name].length === 0) {
                            delete idsByOrigImgName[filesToUpload[imgKey].name];
                        }
                        delete filesToUpload[imgKey];
                        updateImageDisplay();
                    }
                    if (validFileType(filesToUpload[file])) {
                        para.textContent = `File name ${file}, file size ${returnFileSize(filesToUpload[file].size)}.`;
                        const image = document.createElement('img');
                        image.src = URL.createObjectURL(filesToUpload[file]);

                        listItem.appendChild(image);
                        listItem.appendChild(para);
                    } else {
                        para.textContent = `File name ${file}: Not a valid file type. Update your selection.`;
                        listItem.appendChild(para);
                    }

                    list.appendChild(listItem);
                });
            };
        }

        function returnFileSize(number) {
            if (number < 1024) {
                return number + 'bytes';
            } else if (number >= 1024 && number < 1048576) {
                return (number / 1024).toFixed(1) + 'KB';
            } else if (number >= 1048576) {
                return (number / 1048576).toFixed(1) + 'MB';
            }
        }

        function setModeMarker() {
            document.getElementById('mode-marker').innerHTML = numErrors > 0 ?
                'Note: currently displaying <strong>only</strong> images that need manual alignment to be analyzed.' : '';
        }

        var setCurrentImgName = function () {
            setModeMarker();
            document.getElementById('current-img').innerText =
                `Viewing image ${currentImgIndex + 1} of ${orderedImgNames.length}: ${orderedImgNames[currentImgIndex]} (Shift + scroll to zoom)`;
        }

        var appendToFilename = function (filename, addition) {
            return filename.replace(/(\.[\w\d_-]+)$/i, `${addition}$1`)
        }

        var displayLoadingMessage = function (dom) {
            let texts = ['Loading.', 'Loading..', 'Loading...'];
            let textIndex = 0;
            dom.loadingInterval = setInterval(() => {
                dom.innerText = texts[textIndex];
                textIndex += 1;
                if (textIndex === texts.length) {
                    textIndex = 0;
                }
            }, 400);
        }

        var collectEditedCounts = function () {
            let editedCounts = {}
            orderedImgNames.forEach((name, i) => {
                if (!eggLayingRegions[i] || eggLayingRegions[i].bad) {
                    return;
                }
                editedCounts[name] = {};
                Object.keys(eggLayingRegions[i]).forEach(region => {
                    if (eggLayingRegions[i][region].beenEdited()) {
                        editedCounts[name][eggLayingRegions[i][region].bboxIndex] =
                            eggLayingRegions[i][region].text.content;
                    }
                });
            });
            return editedCounts;
        }

        var updateRetryAnalysisButtonAppearance = function () {
            document.getElementById('retry-analysis-button').style.color =
                indicesOfUntriagedImages().length == 0 ? 'black' : colors.lightGrey;
        }

        var setupErrorAnnotationButtonHandlers = function () {
            if (numErrors == 0) {
                return;
            }
            document.getElementById('chamber-type-select').onchange = (evt) => {
                chamberRealignmentData[currentImgIndex] = {
                    type: evt.target.value,
                    ignored: chamberRealignmentData[currentImgIndex].ignored,
                    file_name: chamberRealignmentData[currentImgIndex].file_name
                };
                updateRetryAnalysisButtonAppearance();
                redrawCanvas();
            };
            document.getElementById('ignore-img').onclick = () => {
                let chamberTypeButton = document.getElementById('chamber-type-select');
                let chamberButtonDisabled = chamberTypeButton.hasAttribute('disabled');
                if (chamberButtonDisabled) {
                    chamberRealignmentData[currentImgIndex].ignored = false;
                    chamberTypeButton.removeAttribute('disabled');
                    chamberTypeButton.dispatchEvent(new CustomEvent('change'));
                }
                else {
                    chamberRealignmentData[currentImgIndex].ignored = true;
                    chamberTypeButton.setAttribute('disabled', true);
                    chamberTypeButton.value = 'null';
                    resetCurrentRealignmentMarkers();
                    chamberTypeButton.dispatchEvent(new CustomEvent('change'));
                }
                updateIgnoreButtonText();
                updateRetryAnalysisButtonAppearance();
            };
            document.getElementById('retry-analysis-button').onclick = () => {
                let untriaged = indicesOfUntriagedImages();
                if (untriaged.length > 0) {
                    document.getElementById('mode-marker').innerHTML = 'Images can only be submitted if' +
                        ' each one has either been assigned a chamber type or marked as ignored.' +
                        ' <br>The following images still need attention:' +
                        ` ${untriaged.length > 1 ? `${untriaged.slice(0, -1).join(', ')
                            } and ${untriaged[untriaged.length - 1]}` : untriaged[0]}.`;
                    setTimeout(() => {
                        setModeMarker();
                    }, 3000);
                    return;
                }
                transformAlignmentGuidelinePoints();
                let dataToSend = {
                    chamberData: chamberRealignmentData, sid
                };
                $.ajax({
                    url: '/manual-recount',
                    type: "POST",
                    data: JSON.stringify(dataToSend),
                    contentType: "application/json",
                    success: function (data) {
                        console.log('Success!');
                    }
                });
                clearAllUpdates();
            }
        }

        function transformAlignmentGuidelinePoints() {
            Object.keys(chamberRealignmentData).forEach(k => {
                if (chamberRealignmentData[k].ignored) {
                    return;
                }
                Object.keys(chamberRealignmentData[k].nodes).forEach(node => {
                    let pt = chamberRealignmentData[k].nodes[node];
                    chamberRealignmentData[k].nodes[node] = [
                        (pt[0] - leftPadding) / scalingFactor,
                        (pt[1] - upperPadding) / scalingFactor
                    ];
                })
            });
        }

        var setButtonHandlers = function () {
            document.getElementById('download-csv').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target);
                socket.emit('prepare-csv', {
                    time: Date.now(),
                    sid: sid,
                    editedCounts: collectEditedCounts()
                })
            }
            document.getElementById('download-imgs').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target)
                let requestTs = Date.now();
                socket.emit('prepare-annot-imgs-zip', {
                    time: requestTs,
                    sid: sid,
                    editedCounts: collectEditedCounts()
                });

            }
            document.getElementById('user-select').onchange = (evt) => {
                window.localStorage.setItem('user', evt.target.value);
            }
            setupErrorAnnotationButtonHandlers();
            document.getElementById('submit-error-report').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                if (document.getElementById('user-select').value === 'null') {
                    document.getElementById('user-select').style.borderColor = 'red';
                    document.getElementById('user-select').style.fontWeight = 'bold';
                    evt.target.innerText = 'Please set user first and try again.';
                    setTimeout(() => {
                        evt.target.innerText = 'Submit error report for all images';
                        evt.target.removeAttribute('disabled');
                        document.getElementById('user-select').style.borderColor = 'black';
                        document.getElementById('user-select').style.fontWeight = 'normal';
                    }, 2500);
                    return;
                }
                displayLoadingMessage(evt.target);
                socket.emit('submit-error-report', {
                    editedCounts: collectEditedCounts(),
                    sid: sid,
                    user: window.localStorage.getItem('user')
                });
            }
            if (orderedImgNames.length === 1) {
                document.getElementById('prev-img').setAttribute('disabled', true);
                document.getElementById('next-img').setAttribute('disabled', true);
                return
            }
            document.getElementById('prev-img').onclick = (evt) => {
                let newImgIdx = currentImgIndex - 1;
                if (numErrors > 0) {
                    while (!hasErrors[newImgIdx] && newImgIdx >= 0) {
                        newImgIdx -= 1;
                    }
                }
                if (newImgIdx >= 0) {
                    previousImgIndex = currentImgIndex;
                    currentImgIndex = newImgIdx;
                    setChamberTypeSelector();
                    setIgnoreSelector();
                    redrawCanvas();
                    if (newImgIdx == 0) {
                        evt.target.setAttribute('disabled', true);
                    } else {
                        evt.target.removeAttribute('disabled');
                    }
                    document.getElementById('next-img').removeAttribute('disabled');
                }
            }
            document.getElementById('next-img').onclick = (evt) => {
                let newImgIdx = currentImgIndex + 1;
                if (numErrors > 0) {
                    while (!hasErrors[newImgIdx] && newImgIdx <= orderedImgNames.length - 1) {
                        newImgIdx += 1;
                    }
                }
                if (newImgIdx <= orderedImgNames.length) {
                    previousImgIndex = currentImgIndex;
                    currentImgIndex = newImgIdx;
                    setChamberTypeSelector();
                    setIgnoreSelector();
                    redrawCanvas();
                    if (evt.target.disabled) {
                        evt.target.removeAttribute('disabled');
                    }
                    if (newImgIdx > 0) {
                        document.getElementById('prev-img').removeAttribute('disabled');
                    }
                }
                if (newImgIdx >= orderedImgNames.length - 1) {
                    evt.target.setAttribute('disabled', true);
                    document.getElementById('prev-img').removeAttribute('disabled');
                }
            }
        }

        var setChamberTypeSelector = function () {
            if (numErrors > 0) {
                if (chamberRealignmentData[currentImgIndex] && !['', 'null'].includes(chamberRealignmentData[currentImgIndex].type) > 0) {
                    document.getElementById('chamber-type-select').value = chamberRealignmentData[currentImgIndex].type;
                }
                else {
                    document.getElementById('chamber-type-select').value = 'null';
                }
            }
        }

        var updateIgnoreButtonText = function () {
            document.getElementById('ignore-img').innerText = `${document.getElementById(
                'chamber-type-select').hasAttribute('disabled') ? 'Uni' : 'I'}gnore image`;

        }

        var setIgnoreSelector = function () {
            if (numErrors === 0) {
                return;
            }
            let chamberTypeButton = document.getElementById('chamber-type-select')
            if (!chamberRealignmentData[currentImgIndex] || !chamberRealignmentData[currentImgIndex].ignored) {
                chamberTypeButton.removeAttribute('disabled');
            }
            else if (chamberRealignmentData[currentImgIndex].ignored) {
                chamberTypeButton.setAttribute('disabled', true);
            }
            updateIgnoreButtonText();
        }

        function base64ToBlob(base64, mime) {
            mime = mime || '';
            var sliceSize = 1024;
            var byteChars = window.atob(base64);
            var byteArrays = [];

            for (var offset = 0, len = byteChars.length; offset < len; offset += sliceSize) {
                var slice = byteChars.slice(offset, offset + sliceSize);

                var byteNumbers = new Array(slice.length);
                for (var i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                var byteArray = new Uint8Array(byteNumbers);

                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, { type: mime });
        }

        var updateRealignmentGuide = function () {
            $('#help-pane').empty();
            let noChamberTypeSelected = ['null', ''].includes(chamberRealignmentData[currentImgIndex].type);
            let imageIgnored = document.getElementById('chamber-type-select').hasAttribute('disabled');
            if (noChamberTypeSelected || imageIgnored) {
                document.getElementById('help-pane').style.height = '300px';
                document.getElementById('help-pane').innerText = imageIgnored ? 'To add alignment markers' +
                    ' to this image, click "Unignore image."' : "Please select" +
                " a chamber type from the menu at left.";
                return;
            }
            document.getElementById('help-pane').style.height = '400px';
            document.getElementById('help-pane').innerText = 'Please drag and' +
                ' resize the two lines until they line up with the outer edges of' +
                ' the agarose areas on the upper and left sides, as shown.'
            let exampleImg = document.createElement('img');
            exampleImg.setAttribute('src', `static/imgs/${chamberRealignmentData[currentImgIndex].type}_chamber_lines.jpg`);
            document.getElementById('help-pane').append(exampleImg);
            document.getElementById('help-pane').innerHTML += '<span>If the agarose is cut off' +
                " by the edge of the image, then the line can extend past the image's" +
                " border. If it is not possible to mark the image's alignment, then click" +
                ' "Ignore image."</span>'
        }

        var resetCurrentRealignmentMarkers = function () {
            Object.keys(currentRealignmentMarkers.lines).forEach(l => {
                currentRealignmentMarkers.lines[l].remove();
            })
            Object.keys(currentRealignmentMarkers.circles).forEach(c => {
                currentRealignmentMarkers.circles[c].remove();
            })
            currentRealignmentMarkers = { lines: {}, circles: {} };
        }

        var addRealignmentEndpointEventHandlers = function (toReset = null) {
            Object.keys(currentRealignmentMarkers.circles).forEach((circle) => {
                if (toReset !== null && circle !== toReset) {
                    return;
                }
                currentRealignmentMarkers.circles[circle].onMouseEnter = () => {
                    if (draggingRealignmentMarker) {
                        return;
                    }
                    let newCircle = new paper.Path.Circle({
                        center: currentRealignmentMarkers.circles[circle].position,
                        radius: 5,
                        strokeColor: 'red',
                        fillColor: 'red'
                    })

                    currentRealignmentMarkers.circles[circle].remove();
                    currentRealignmentMarkers.circles[circle] = newCircle;
                    addRealignmentEndpointEventHandlers(circle);
                };
                currentRealignmentMarkers.circles[circle].onMouseLeave = () => {
                    if (draggingRealignmentMarker) {
                        return;
                    }
                    let newCircle = new paper.Path.Circle({
                        center: currentRealignmentMarkers.circles[circle].position,
                        radius: 2,
                        strokeColor: 'red',
                        fillColor: 'red'
                    });
                    currentRealignmentMarkers.circles[circle].remove();
                    currentRealignmentMarkers.circles[circle] = newCircle;
                    addRealignmentEndpointEventHandlers(circle);
                };
                currentRealignmentMarkers.circles[circle].onMouseDrag = (evt) => {
                    draggingRealignmentMarker = true;
                    currentRealignmentMarkers.circles[circle].position.x += evt.delta.x;
                    currentRealignmentMarkers.circles[circle].position.y += evt.delta.y;
                    currentRealignmentMarkers.circles[circle].opacity = 0.0;
                    // if it's the middle point, both lines need to move.
                    let lineDefaults = { strokeColor: 'red', strokeWidth: 2 }
                    if (circle === 'end1' || circle === 'middle') {
                        currentRealignmentMarkers.lines.toEnd1.remove();
                        currentRealignmentMarkers.lines.toEnd1 = new paper.Path.Line({
                            ...{
                                from: currentRealignmentMarkers.circles.middle.position,
                                to: currentRealignmentMarkers.circles.end1.position,
                            }, ...lineDefaults
                        }
                        );
                    }
                    if (circle === 'end2' || circle === 'middle') {
                        currentRealignmentMarkers.lines.toEnd2.remove();
                        currentRealignmentMarkers.lines.toEnd2 = new paper.Path.Line({
                            ...
                            {
                                from: currentRealignmentMarkers.circles.middle.position,
                                to: currentRealignmentMarkers.circles.end2.position,
                            }, ...lineDefaults
                        }
                        )
                    }
                }
                currentRealignmentMarkers.circles[circle].onMouseUp = () => {
                    draggingRealignmentMarker = false;
                    currentRealignmentMarkers.circles[circle].opacity = 1.0;
                    chamberRealignmentData[currentImgIndex].nodes[circle] = [
                        currentRealignmentMarkers.circles[circle].position.x,
                        currentRealignmentMarkers.circles[circle].position.y
                    ]
                }
            });
        }

        var drawChamberAlignmentMarkers = function () {
            if (!chamberRealignmentData[currentImgIndex].nodes) {
                chamberRealignmentData[currentImgIndex].nodes = {
                    end1: [leftPadding + 0.9 * backgroundRaster.bounds.width, upperPadding + 80],
                    middle: [leftPadding + 80, upperPadding + 80],
                    end2: [leftPadding + 80, upperPadding + 0.9 * backgroundRaster.bounds.height]
                }
            }
            let currentNodes = chamberRealignmentData[currentImgIndex].nodes;
            currentRealignmentMarkers.lines = {
                toEnd1:
                    new paper.Path.Line({
                        from: new paper.Point(currentNodes.end1),
                        to: new paper.Point(currentNodes.middle),
                        strokeColor: 'red',
                        strokeWidth: 2
                    }), toEnd2:
                    new paper.Path.Line({
                        from: new paper.Point(currentNodes.end2),
                        to: new paper.Point(currentNodes.middle),
                        strokeColor: 'red',
                        strokeWidth: 2
                    })
            };
            Object.keys(currentNodes).forEach(node => {
                currentRealignmentMarkers.circles[node] =
                    new paper.Path.Circle({
                        center: currentNodes[node],
                        radius: 2,
                        strokeColor: 'red',
                        fillColor: 'red'
                    });
            });
            addRealignmentEndpointEventHandlers();
        }

        var redrawCanvas = function () {
            canvasLoaded = false;

            if (numErrors > 0) {
                if (!chamberRealignmentData[currentImgIndex]) {
                    chamberRealignmentData[currentImgIndex] = {
                        type: '',
                        file_name: orderedImgNames[currentImgIndex]
                    }
                }
                updateRealignmentGuide();
                resetCurrentRealignmentMarkers();
            }


            setCurrentImgName()
            if (backgroundRaster) {
                backgroundRaster.remove();
            }
            if (previousImgIndex !== null && eggLayingRegions[previousImgIndex]) {
                if (eggLayingRegions[previousImgIndex].bad) {
                    eggLayingRegions[previousImgIndex].text.remove();
                } else {
                    Object.keys(eggLayingRegions[previousImgIndex]).forEach(region => {
                        eggLayingRegions[previousImgIndex][region].text.remove();
                        eggLayingRegions[previousImgIndex][region].outline.remove();
                        eggLayingRegions[previousImgIndex][region].fill.remove();
                    });
                }
            }
            $('#updates').append(`<img id=pic src="/uploads/${orderedImgNames[currentImgIndex]}?lastmod=${Date.now()}">`);
            let rotationAngle = rotationAngles[orderedImgNames[currentImgIndex]] || 0;
            paper.project.clear();
            backgroundRaster = new paper.Raster('pic');
            pic = document.getElementById('pic');
            backgroundRaster.onLoad = () => {
                if (rotationAngle) {
                    backgroundRaster.rotate(-rotationAngle * 180 / Math.PI)
                }
                backgroundRaster.fitBounds(paper.view.viewSize);
                scalingFactor = Math.min(canvasHeight / (Math.abs(pic.width * Math.sin(rotationAngle)) +
                    Math.abs(pic.height * Math.cos(rotationAngle))),
                    canvasWidth / (Math.abs(pic.width * Math.cos(rotationAngle)) +
                        Math.abs(pic.height * Math.sin(rotationAngle))));
                document.getElementById('pic').remove();
                upperPadding = 0.5 * (canvasHeight - backgroundRaster.bounds.height)
                    + Math.abs(0.5 * Math.tan(rotationAngle) * backgroundRaster.bounds.width);
                leftPadding = 0.5 * (canvasWidth - backgroundRaster.bounds.width)
                    + Math.abs(0.5 * Math.tan(rotationAngle) * backgroundRaster.bounds.height);
                if ('error' in annotations[orderedImgNames[currentImgIndex]]) {
                    let pointText = new paper.PointText(new paper.Point(paper.view.center.x,
                        paper.view.center.y));
                    pointText.content = errorMessages[annotations[
                        orderedImgNames[currentImgIndex]].error];
                    pointText.justification = 'center';
                    pointText.fillColor = 'red';
                    pointText.fontSize = '40px';
                    eggLayingRegions[currentImgIndex] = { bad: true, text: pointText }
                    if (!['', 'null'].includes(chamberRealignmentData[currentImgIndex].type)) {
                        drawChamberAlignmentMarkers();
                    }
                } else {
                    if (!eggLayingRegions[currentImgIndex]) {
                        eggLayingRegions[currentImgIndex] = {};
                        annotations[orderedImgNames[currentImgIndex]].forEach((annotation, i) => {
                            let x = annotation.x * scalingFactor + leftPadding;
                            let y = annotation.y * scalingFactor + upperPadding;
                            let bbox = annotation.bbox;
                            bbox = bbox.map(n => n * scalingFactor);
                            let textOrigin = new paper.Point(x, y)
                            let pointText = new paper.PointText(new paper.Point(x, y));
                            pointText.justification = 'center';
                            pointText.fillColor = 'black';
                            pointText.content = annotation.count;
                            pointText.fontSize = defaultFontSize;
                            let rectangle = new paper.Rectangle(
                                new paper.Point(bbox[0] + leftPadding, bbox[1] + upperPadding),
                                new paper.Point(bbox[0] + bbox[2] + leftPadding, bbox[1] + bbox[3] + upperPadding));
                            rectPath = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                            rectPath.strokeColor = colors.grey;
                            let innerRect = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                            innerRect.fillColor = 'black';
                            innerRect.opacity = 0;
                            addHoverHandler(innerRect, currentImgIndex);
                            eggLayingRegions[currentImgIndex][innerRect.id] = {
                                outline: rectPath,
                                fill: innerRect,
                                text: pointText,
                                bboxIndex: i,
                                originalCount: annotation.count.toString(),
                                beenEdited() {
                                    return this.originalCount !== this.text.content;
                                }
                            };
                        });
                    } else {
                        Object.keys(eggLayingRegions[currentImgIndex]).forEach(region => {
                            // recreate the text
                            let reg = eggLayingRegions[currentImgIndex][region];
                            if (reg.beenEdited()) {
                                drawTextForEditedCount(reg, reg.text.content);
                            } else {
                                let origText = reg.text;
                                reg.text = new paper.PointText(new paper.Point(origText.point.x,
                                    origText.point.y));
                                reg.text.content = origText.content;
                                reg.text.justification = 'center';
                                reg.text.fillColor = reg.beenEdited() ? colors.red : 'black';
                                reg.text.fontSize = origText.fontSize;
                            }
                            // recreate the outline
                            let origOutline = reg.outline;
                            let rectangle = new paper.Rectangle(
                                new paper.Point(origOutline.bounds.x, origOutline.bounds.y),
                                new paper.Point(origOutline.bounds.x + origOutline.bounds.width,
                                    origOutline.bounds.y + origOutline.bounds.height)
                            );
                            reg.outline = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                            reg.outline.strokeColor = reg.beenEdited() ? colors.red : colors.grey;
                            // recreate the inner fill
                            let origFill = reg.fill;
                            reg.fill = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                            reg.fill.fillColor = 'black';
                            reg.fill.opacity = 0;
                            eggLayingRegions[currentImgIndex][reg.fill.id] = {
                                outline: reg.outline,
                                fill: reg.fill,
                                text: reg.text,
                                bboxIndex: reg.bboxIndex,
                                originalCount: reg.originalCount,
                                beenEdited() {
                                    return this.originalCount !== this.text.content;
                                }
                            }
                            delete eggLayingRegions[currentImgIndex][origFill.id];
                            addHoverHandler(reg.fill, currentImgIndex);
                        });
                    }
                }
                origCenter = paper.view.center;
                canvasLoaded = true;
            }
        }

        var drawTextForUneditedCount = (reg) => {
            if (reg.textPredicted) {
                reg.textPredicted.remove();
            }
            let x, y;
            if (reg.centeredTextPosition) {
                x = reg.centeredTextPosition.x;
                y = reg.centeredTextPosition.y
            } else {
                x = reg.text.point.x;
                y = reg.text.point.y;
            }
            reg.text.remove();
            reg.text = new paper.PointText(new paper.Point(x, y));
            reg.text.content = reg.originalCount;
            reg.text.justification = 'center';
            reg.text.fillColor = 'black';
            reg.text.fontSize = defaultFontSize;
        }

        var drawTextForEditedCount = (reg, value) => {
            if (!reg.centeredTextPosition) {
                reg.centeredTextPosition = reg.text.point;
            }
            let origText = reg.text;
            reg.text.remove();
            reg.text = new paper.PointText(new paper.Point(reg.centeredTextPosition.x, reg.centeredTextPosition.y - 10));
            reg.text.content = value;
            reg.text.justification = 'center';
            reg.text.fillColor = colors.red;
            reg.text.fontSize = origText.fontSize;
            if (reg.textPredicted) {
                reg.textPredicted.remove();
            }
            reg.textPredicted = new paper.PointText(new paper.Point(reg.centeredTextPosition.x, reg.centeredTextPosition.y + 10));
            reg.textPredicted.content = reg.originalCount;
            reg.textPredicted.justification = 'center';
            reg.textPredicted.fillColor = 'black';
            reg.textPredicted.fontSize = origText.fontSize;
        };

        var addHoverHandler = function (path, index) {
            path.onMouseEnter = () => {
                if (inputAmender) {
                    return;
                }
                if (eggLayingRegions[index][path.id].beenEdited()) {
                    eggLayingRegions[index][path.id].outline.strokeWidth = 2;
                    return;
                }
                eggLayingRegions[index][path.id].text.fillColor = colors.red;
                eggLayingRegions[index][path.id].outline.strokeColor = colors.red;
            }
            path.onMouseLeave = () => {
                if (inputAmender) {
                    return;
                }
                eggLayingRegions[index][path.id].outline.strokeWidth = 1;
                if (eggLayingRegions[index][path.id].beenEdited()) {
                    return;
                }
                eggLayingRegions[index][path.id].text.fillColor = 'black';
                eggLayingRegions[index][path.id].outline.strokeColor = colors.grey;
            }
            path.onClick = (event) => {
                if (inputAmender) {
                    return;
                }
                let viewer = document.getElementById('viewer')
                inputAmender = document.createElement('input');
                eggLayingRegions[index][path.id].text.opacity = 0;
                pathAmendId = path.id;
                inputAmender.type = 'text';
                inputAmender.setAttribute('class', 'live-count-editor');
                var viewportOffset = viewer.getBoundingClientRect();
                let text = eggLayingRegions[index][path.id].text;
                let fieldHeight = text.bounds.height * paper.view.zoom;
                let fieldWidth = text.bounds.width * paper.view.zoom;
                eggLayingRegions[index][path.id].outline.strokeWidth = 2;
                inputAmender.style = 'position: absolute; left:' +
                    ` ${viewer.offsetLeft + eggLayingRegions[index][path.id].outline.bounds.x}px; ` +
                    `top: ${viewer.offsetTop + eggLayingRegions[index][path.id].outline.bounds.y}px; ` +
                    `width: ${50 * paper.view.zoom}px;` +
                    `height: ${26 * paper.view.zoom}px;` +
                    `font-size: ${0.75 * text.fontSize * paper.view.zoom}px;`
                inputAmender.placeholder = 'e.g., 42';
                viewer.appendChild(inputAmender);
                inputAmender.focus();
                eggLayingRegions[index][path.id].text.fillColor = colors.red;
                eggLayingRegions[index][path.id].outline.strokeColor = colors.red;
                inputAmender.onkeydown = checkIfEnterKeyPressed
                inputAmender.oninput = amendEggCount;
            }
        }

        var checkIfEnterKeyPressed = function (event) {
            lastKeyPressed = event.code;
            if (!lastKeyPressed.startsWith('Digit') && !lastKeyPressed.startsWith('Key')) {
                amendEggCount(event, inputAmender.value);
            }
        }

        var amendEggCount = function (event, value = null) {
            if (lastKeyPressed === 'Escape') {
                let reg = eggLayingRegions[currentImgIndex][pathAmendId];
                reg.text.fillColor = reg.beenEdited() ? colors.red : 'black';
                reg.outline.strokeColor = reg.beenEdited() ? colors.red : colors.grey;
                reg.outline.strokeWidth = 1;
                reg.text.opacity = 1.0;
                inputAmender.remove();
                inputAmender = null;
                return;
            }
            let errorGrey = '#b99393';
            let okGrey = ' #acacac';
            if (!value) {
                value = this.value.toString()
            }
            if (lastKeyPressed === 'Enter') {
                if (isNormalInteger(value)) {
                    if (value == eggLayingRegions[currentImgIndex][pathAmendId].originalCount) {
                        idsWithEdits.delete(pathAmendId)
                        drawTextForUneditedCount(eggLayingRegions[currentImgIndex][pathAmendId]);
                    } else {
                        idsWithEdits.add(pathAmendId)
                        drawTextForEditedCount(eggLayingRegions[currentImgIndex][pathAmendId], value);
                    }
                    inputAmender.remove();
                    inputAmender = null;
                    if (idsWithEdits.size > 0) {
                        document.getElementById('submit-error-report').removeAttribute('hidden');
                    } else {
                        document.getElementById('submit-error-report').setAttribute('hidden', 'true');
                    }
                } else {
                    inputAmender.style.backgroundColor = errorGrey;
                }
            } else if (isNormalInteger(value)) {
                inputAmender.style.backgroundColor = okGrey;
            } else {
                inputAmender.style.backgroundColor = errorGrey;
            }
        }

        var dividerString = function () {
            return '<div class=divider></div>'
        }

        var buttonString = function (id, text, hidden = false) {
            let doms = [`<button id=${id} ${hidden ? 'hidden' : ''}>${text}</button>`]
            if (!hidden) {
                doms.push(dividerString());
            }
            return doms
        }

        var errorAnnotationButtons = function () {
            return [{ id: 'ignore-img', text: 'Ignore image' }, {
                id: 'chamber-type-select', text: 'Chamber type: not set',
                selectOptions: [{ value: 'sixByFour', text: 'Chamber type: 6 rows x 4 cols' },
                { value: 'fiveByThree', text: 'Chamber type: 5 rows x 3 cols' },
                { value: 'opto', text: 'Chamber type: optogenetic' },
                { value: 'large', text: 'Chamber type: large' }
                ]
            },
            { id: 'retry-analysis-button', text: 'Submit images for re-analysis' }
            ]
        }

        var analyzedImagesButtons = function (hidden = false) {

            userSelectOptions = [];
            {% for user in users %}
            userSelectOptions.push({ value: '{{user}}', text: 'User: {{user}}' })
            {% endfor %}
            return [
                { id: 'download-imgs', text: 'Download annotated images', hidden: hidden },
                {
                    id: 'submit-error-report', text: 'Submit error report for all images',
                    hidden: true
                },
                {
                    id: 'user-select', text: 'User: not set',
                    selectOptions: userSelectOptions, hidden: hidden
                }
            ];
        }

        var getContextSpecificButtons = function () {
            if (numErrors > 0) {
                document.getElementById('download-csv').setAttribute('hidden', true);
                return errorAnnotationButtons().concat(analyzedImagesButtons(hidden = true));
            }
            return analyzedImagesButtons();
        }

        var displayImageAnalysisErrorMessage = function () {
            document.getElementById('modal-1-close').removeAttribute('hidden');
            document.getElementById('modal-1-title').innerText = 'Image analysis error';
            document.getElementById('modal-1-message').innerText =
                `We were not able to detect the egg-laying regions in ${numErrors}` +
                ' of your images, but with your help, they can still be analyzed.' +
                ' After dismissing this message, any images with errors will be displayed' +
                ' in a tool allowing you to mark two boundary lines on the image which' +
                ' will allow it to be split into individual regions. Click X to continue.'
            document.getElementById('modalToggle').click();
        }

        var setupCanvas = function (isRetry = false) {
            if (isRetry) {
                hasErrors = [];
                numErrors = 0;
            } else {
                hasErrors = Object.keys(annotations).map((k) => {
                    return 'error' in annotations[k];
                });
                numErrors = hasErrors.filter(Boolean).length;
            }

            if (numErrors > 0) {
                document.getElementById('updates-by-image').innerHTML = '';
                chamberRealignmentData = {};
                displayImageAnalysisErrorMessage();
            }

            const constant_buttons = [{ id: 'reset-view', text: 'Reset view' },
            {
                id: 'prev-img', text: 'Previous image',
            },
            { id: 'next-img', text: 'Next image' }];



            $('#updates').append('<div id=viewer-nav></div>');
            $('#viewer-nav').append('<div id=button-row></div>');
            constant_buttons.forEach(b => {
                let doms = buttonString(b.id, b.text, b.hidden);
                doms.forEach(d => {
                    $('#button-row').append(d);
                })
            });
            getContextSpecificButtons().forEach(b => {
                if (b.selectOptions) {
                    $('#button-row').append(`<select id=${b.id} ${b.hidden ? 'hidden' : ''}></select>`);
                    selectDOM = document.getElementById(b.id);
                    let opt = document.createElement('option');
                    opt.value = null;
                    opt.innerText = b.text;
                    selectDOM.append(opt);
                    b.selectOptions.forEach(so => {
                        opt = document.createElement('option');
                        opt.innerText = so.text;
                        opt.value = so.value;
                        selectDOM.appendChild(opt)
                    });
                    $('#button-row').append(dividerString());
                }
                else {
                    let doms = buttonString(b.id, b.text, b.hidden);
                    doms.forEach(d => {
                        $('#button-row').append(d);
                    })
                }
            });

            if (numErrors > 0) {
                currentImgIndex = hasErrors.findIndex(el => el === true);
                document.getElementById('prev-img').setAttribute('disabled', true);
                if (numErrors === 1) {
                    document.getElementById('next-img').setAttribute('disabled', true);
                }
            } else {
                currentImgIndex = 0;
                document.getElementById('prev-img').setAttribute('disabled', true);
                if (orderedImgNames.length > 1) {
                    document.getElementById('next-img').removeAttribute('disabled');
                } else {
                    document.getElementById('next-img').setAttribute('disabled', true);
                }
            }

            if (window.localStorage.getItem('user')) {
                selectDOM.value = window.localStorage.getItem('user');
            }
            $('#viewer-nav').append('<div class=divider></div>');
            $('#updates').append('<br><div id=current-img-parent><p id=mode-marker></p><p id=current-img></p>');
            setCurrentImgName()
            setButtonHandlers()
            $('#reset-view').click(reposition)
            $('#updates').append('<div id=viewer></div>')
            $('#viewer').append('<canvas keepalive=true id=detectionResults></canvas>');
            canvas = document.getElementById('detectionResults');
            if (numErrors > 0) {
                $('#viewer').append('<div id=help-pane></div>');
                document.getElementById('retry-analysis-button').style.color = colors.lightGrey;
            }
            paper.install(window);
            paper.setup(canvas);
            paper.view.viewSize = new paper.Size(canvasWidth, canvasHeight);
            redrawCanvas();
            setPointerHandlers();
            setDragHandler();
        }
        var indicesOfUntriagedImages = function () {
            let untriaged = []
            for (let index = 0; index < orderedImgNames.length; index++) {
                if (!hasErrors[index]) {
                    continue;
                }
                if (!chamberRealignmentData[index]) {
                    untriaged.push(index + 1)
                }
                else if (!(chamberRealignmentData[index].ignored ||
                    !['', 'null'].includes(chamberRealignmentData[index].type))) {
                    untriaged.push(index + 1);
                }
            }
            return untriaged;
        }

        var zoomInAndOut = e => {
            if (!e.shiftKey || inputAmender) {
                return;
            }
            e.preventDefault();
            if (lastScrollTime && Date.now() - lastScrollTime < 250) {
                return;
            }
            lastScrollTime = Date.now();
            let view = paper.view;
            let viewPosition = view.viewToProject(
                new paper.Point(e.offsetX, e.offsetY)
            );

            let transform = changeZoom(e.deltaY, viewPosition);
            if (paper.view.zoom <= 1 && transform.zoom <= 1) {
                return;
            }
            if (transform.zoom < 10 && transform.zoom > 0.01) {
                newScale = 1 / transform.zoom;
                paper.view.zoom = transform.zoom;
                paper.view.center = view.center.add(transform.offset);
            }
        }

        var changeZoom = (delta, p) => {
            let oldZoom = paper.view.zoom;
            let c = paper.view.center;
            let factor = 1 + zoom;

            let zoomTemp = delta < 0 ? oldZoom * factor : oldZoom / factor;
            let beta = oldZoom / zoomTemp;
            let pc = p.subtract(c);
            let a = p.subtract(pc.multiply(beta)).subtract(c);

            return { zoom: zoomTemp, offset: a };
        }

        var setPointerHandlers = function () {
            canvas.addEventListener('wheel', zoomInAndOut, { passive: false });
            paper.view.on('mousedown', function () {
                pointerDown = true;
                timeDownUp = new Date().getTime();
                dragStart = true;
            });
            paper.view.on('mouseup', function () {
                pointerDown = false;
                timeDownUp = new Date().getTime();
                dragStart = false;
            });
        }

        var setDragHandler = () => {
            var toolPan = new paper.Tool();
            toolPan.onMouseDrag = function (evt) {
                if (inputAmender || draggingRealignmentMarker) {
                    return;
                }
                var timeMove = new Date().getTime();
                if (timeMove > timeDownUp) {
                    if (dragStart) {
                        var offset = new paper.Point(evt.downPoint.x - evt.point.x,
                            evt.downPoint.y - evt.point.y);
                        let new_center = paper.view.center.add(offset);
                        paper.view.setCenter(new_center);
                    }
                } else {
                    timeDownUp = null;
                }
            };
        }

        function reposition() {
            paper.view.zoom = 1;
            paper.view.center = origCenter;
            dragStart = false;
        }
    </script>

    <div class="modal" id="modal-1" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container w-90 w-40-ns" id='egg-flagger-div' role="dialog" aria-modal="true"
                aria-labelledby="modal-1-title">
                <header class="modal__header">
                    <h3 id="modal-1-title" class="modal__title">
                        Session expired
                        </h2>
                        <button id=modal-1-close hidden aria-label="Close modal" data-micromodal-close></button>
                </header>
                <div id="modal-1-message">
                    <p>The connection to the server has been lost; please refresh the page to continue.</p>
                </div>
            </div>
        </div>
    </div>
    <div id="page-mask"></div>
    <script>
        MicroModal.init();
    </script>
</body>