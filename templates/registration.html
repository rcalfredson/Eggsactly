<!doctype html>

<head>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/main.css') }}">
    <style>
        body {
            display: none
        }
    </style>
    <script src="https://cdn.socket.io/socket.io-3.0.1.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.7/paper-full.js"></script>
    <script src="../static/js/micromodal.min.js"></script>
    <title>Egg Counting</title>
</head>

<body>
    <script type="text/javascript">
        const socket = io();
        const colors = {
            grey: '#313036',
            red: '#fc2c03'
        };
        const errorMessages = {
            CountingException: 'Image could not be analyzed.',
            CUDAMemoryException: 'Error: system ran out of resources.'
        }
        const defaultFontSize = 17;
        let sid;
        let input, inputs, inputDiv, inputLbl, inputReset, preview;
        let inputAmender;
        let inputAmenderNormalBckgnd;
        let lastKeyPressed;
        let pathAmendId;
        let filesToUpload = {};
        let annotations = {};
        let orderedImgNames = [];
        let eggLayingRegions = [];
        let imgUniqueNames = {};
        let idsByOrigImgName = {};
        let lastPongTime;
        let numFailedPings = 0;
        let zoom = 1.0;
        let idsWithEdits = new Set();
        let lastScrollTime;
        let canvas;
        let canvasLoaded = false;
        let canvasWidth = Math.min(1300, window.innerWidth),
            canvasHeight = Math.min(800, window.innerHeight);
        let pointerDown = false;
        let dragStart = false;
        let timeDownUp;
        let origCenter;
        let currentImgIndex = 0;
        let previousImgIndex;
        let backgroundRaster, pic;

        function isNormalInteger(str) {
            var n = Math.floor(Number(str));
            return n !== Infinity && String(n) === str && n >= 0;
        }

        function fileNameAndExt(str) {
            var file = str.split('/').pop();
            return [file.substr(0, file.lastIndexOf('.')), file.substr(file.lastIndexOf('.') + 1, file.length)]
        }

        function makeid(length, existing_ids = []) {
            var result = '';
            do {
                var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                var charactersLength = characters.length;
                for (var i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * charactersLength));
                }
            } while (existing_ids.indexOf(result) > 0)
            return result;
        }
    </script>
    <form id=notice><label style="background-color: rgb(252, 226, 113);">Please note: the page has changed recently. If
            this box overlaps with the text below it, or if any of the buttons don't have rounded edges and black
            borders, then some features might not have loaded; a complete refresh of the page should resolve this (on
            Mac, use
            Command-Option-R).</label></form>
    <label for="img-upload-1">Upload one or more egg-counting images<br>
        <span style="font-size: small; padding-left: 15px;">
            Note: hold down Ctrl key to select multiple files.
        </span>
    </label>
    <form id=img-form method=post enctype="multipart/form-data">
        <div id=img-inputs>
            <label id="img-upload-lbl" for="img-upload-1">Choose images to upload</label>
            <button hidden id=img-upload-reset type="button">Reset</button>
            <input class=img-upload type=file multiple="multiple" id="img-upload-1" name="img-upload-1">
        </div>
        <div class="preview">
            <p>No files currently selected for upload.</p>
        </div>
        <div>
            <button disabled id='img-upload-btn' type=button>Upload</button>
        </div>
    </form>
    <div id=updates></div>
    <button id="modalToggle" hidden data-micromodal-trigger="modal-1"></button>
    <script type="text/javascript">
        const fileTypes = [
            "image/apng",
            "image/bmp",
            "image/gif",
            "image/jpeg",
            "image/pjpeg",
            "image/png",
            "image/svg+xml",
            "image/tiff",
            "image/webp",
            "image/x-icon"
        ];

        function validFileType(file) {
            return fileTypes.includes(file.type);
        }

        function resetAllVariables() {
            pathAmendId = null;
            inputAmender = null;
            annotations = {};
            orderedImgNames = [];
            eggLayingRegions = [];
            zoom = 1.0;
            idsWithEdits = new Set();
            currentImgIndex = 0;
            previousImgIndex = null;
        }

        $(function () {
            $('#img-upload-btn').click(function () {
                $(this).prop('disabled', true);
                resetAllVariables();
                var form_data = new FormData();
                Object.keys(filesToUpload).forEach((fileName) => {
                    form_data.append(fileName, filesToUpload[fileName]);
                })
                form_data.append('sid', sid);

                $.ajax({
                    type: 'POST',
                    url: '/upload',
                    data: form_data,
                    contentType: false,
                    cache: false,
                    processData: false,
                    success: function (data) {
                        console.log('Success!');
                    },
                });
            });
        });

        $(document).ready(() => {
            $("body").fadeIn(200);
            document.getElementById('page-mask').style.display = 'none';
            document.getElementById('modal-1').removeAttribute('style');
            socket.on('counting-progress', (msg) => {
                $('#updates').append('<p>' + msg.data + '</p>')
            });
            socket.on('counting-error', (msg) => {
                $('#updates').append(`<p style="color: red">${msg.data}</p>`);
                orderedImgNames.push(msg.filename);
                annotations[msg.filename] = {'error': msg.error_type}
            })
            socket.on('counting-done', () => {
                $('#updates').append('<div><button type=button id=download-csv>Download results</button></div>')
                setupCanvas();
                document.getElementById('img-upload-btn').removeAttribute('disabled');
            });
            socket.on('counting-csv', (msg) => {
                $('#updates').append(`<form id=csv-retrieve hidden action=/csvResults/${msg.data}><input hidden value='Download results' type=submit>` +
                    '</input></form>');
                document.getElementById('csv-retrieve').submit();
                document.getElementById('csv-retrieve').remove();
                document.getElementById('download-csv').removeAttribute('disabled');
                clearInterval(document.getElementById('download-csv').loadingInterval);
            });
            socket.on('counting-annotations', (msg) => {
                annotations[msg.filename] = JSON.parse(msg.data);
                orderedImgNames.push(msg.filename);
            });
            socket.on('clear-all', () => {
                if (!!document.getElementById('updates')) {
                    $('#updates').empty();
                }
                annotations = {};
                orderedImgNames = [];
            });
            socket.on('clear-display', () => {
                $('#updates').empty();
            });
            socket.on('report-ready', () => {
                let el = document.getElementById('submit-error-report')
                el.removeAttribute('disabled');
                el.innerText = 'Submitted!';
                setTimeout(() => {
                    el.innerText = 'Submit error report for all images';
                }, 2500)
                clearInterval(el.loadingInterval);
            });
            socket.on('zip-annots-ready', (msg) => {
                $('#updates').append(`<form hidden id=annot-retrieve action=/annot-img/${msg.time}><input id=annot-retrieve-input hidden id= value='Download results' type=submit>` +
                    '</input></form>')
                document.getElementById('annot-retrieve').submit();
                document.getElementById('annot-retrieve').remove();
                document.getElementById('download-imgs').innerText = 'Download annotated images';
                document.getElementById('download-imgs').removeAttribute('disabled');
                clearInterval(document.getElementById('download-imgs').loadingInterval)
            });
            socket.on('sid-from-server', (msg) => {
                if (!sid) {
                    sid = msg.sid;
                    setupPings();
                }
            });

            socket.on('pong', () => {
                lastPongTime = Date.now();
            })
            setUpFileUploadDialog();
        });

        var setupPings = function () {
            setInterval(() => {
                socket.emit('ping', {
                    sid: sid
                });
                setTimeout(() => {
                    if (!lastPongTime || Date.now() - lastPongTime >= 5000) {
                        numFailedPings += 1;
                    } else if (lastPongTime && Date.now() - lastPongTime < 5000) {
                        numFailedPings = 0;
                    }
                    if (numFailedPings >= 2) {
                        document.getElementById('page-mask').style.display = "block";
                        document.getElementById('modalToggle').click();
                    }
                }, 3000)
            }, 5000)
        }

        var setUpFileUploadDialog = function () {
            input = document.getElementById('img-upload-1');
            inputLbl = document.getElementById('img-upload-lbl');
            inputDiv = document.getElementById('img-inputs');
            inputReset = document.getElementById('img-upload-reset')
            preview = document.querySelector('.preview');
            input.addEventListener('change', updateImageDisplay);
            inputReset.onclick = handleResetClick;
        }

        var handleResetClick = function () {
            input.value = "";

            imgUniqueNames = [];
            idsByOrigImgName = {};
            filesToUpload = {};
            updateImageDisplay();
            inputReset.setAttribute('hidden', true);
            inputLbl.innerText = 'Choose images to upload';
            document.getElementById('img-upload-btn').setAttribute('disabled', 'true');
        };

        function updateImageDisplay() {
            while (preview.firstChild) {
                preview.removeChild(preview.firstChild);
            }
            let imgInputs = document.getElementsByClassName('img-upload');
            Array.prototype.forEach.call(input.files, (file) => {
                let id;
                if (file.name in idsByOrigImgName) {
                    id = makeid(3, idsByOrigImgName[file.name])
                } else {
                    id = ''
                }

                let filenameParts = fileNameAndExt(file.name);
                let imgUniqueName = `${filenameParts[0]}${id.length
                    > 0 ? `_${id}` : ''}.${filenameParts[1]}`
                if (file.name in idsByOrigImgName) {
                    idsByOrigImgName[file.name].push(imgUniqueName)
                } else {
                    idsByOrigImgName[file.name] = [imgUniqueName]
                }
                filesToUpload[imgUniqueName] = file
            });
            input.value = "";
            inputLbl.innerText = "Select more images";
            inputReset.removeAttribute('hidden');
            let curFiles = [];
            let inputMapping = []
            if (Object.keys(filesToUpload).length === 0) {
                const para = document.createElement('p');
                para.textContent = 'No files currently selected for upload';
                preview.appendChild(para);
            } else {
                document.getElementById('img-upload-btn').removeAttribute('disabled');
                const list = document.createElement('ol');
                preview.appendChild(list);

                Object.keys(filesToUpload).forEach((file, i) => {
                    const listItem = document.createElement('li');
                    const para = document.createElement('p');
                    const xDiv = document.createElement('div')
                    xDiv.setAttribute('class', 'close-button');
                    xDiv.setAttribute('id', `close-${i}`)
                    xDiv.assocImg = file;
                    const xStroke1 = document.createElement('div');
                    xStroke1.setAttribute('class', 'close-button-stroke1');
                    xStroke1.setAttribute('id', `close-stroke1-${i}`);
                    const xStroke2 = document.createElement('div');
                    xStroke2.setAttribute('class', 'close-button-stroke2');
                    xStroke2.setAttribute('id', `close-stroke2-${i}`);
                    xStroke1.appendChild(xStroke2);
                    xDiv.appendChild(xStroke1);
                    listItem.append(xDiv);
                    xDiv.onclick = (evt) => {
                        let splitId = evt.target.id.split('-');
                        let index = parseInt(splitId[splitId.length - 1]);
                        let imgKey = document.getElementById(`close-${index}`).assocImg;
                        idsByOrigImgName[filesToUpload[imgKey].name].splice(idsByOrigImgName[filesToUpload[imgKey].name].indexOf(imgKey), 1);
                        if (idsByOrigImgName[filesToUpload[imgKey].name].length === 0) {
                            delete idsByOrigImgName[filesToUpload[imgKey].name];
                        }
                        delete filesToUpload[imgKey];
                        updateImageDisplay();
                    }
                    if (validFileType(filesToUpload[file])) {
                        para.textContent = `File name ${file}, file size ${returnFileSize(filesToUpload[file].size)}.`;
                        const image = document.createElement('img');
                        image.src = URL.createObjectURL(filesToUpload[file]);

                        listItem.appendChild(image);
                        listItem.appendChild(para);
                    } else {
                        para.textContent = `File name ${file}: Not a valid file type. Update your selection.`;
                        listItem.appendChild(para);
                    }

                    list.appendChild(listItem);
                });
            };
        }

        function returnFileSize(number) {
            if (number < 1024) {
                return number + 'bytes';
            } else if (number >= 1024 && number < 1048576) {
                return (number / 1024).toFixed(1) + 'KB';
            } else if (number >= 1048576) {
                return (number / 1048576).toFixed(1) + 'MB';
            }
        }

        var setCurrentImgName = function () {
            document.getElementById('current-img').innerText =
                `Viewing image ${orderedImgNames[currentImgIndex]} (Shift + scroll to zoom)`;
        }

        var appendToFilename = function (filename, addition) {
            return filename.replace(/(\.[\w\d_-]+)$/i, `${addition}$1`)
        }

        var displayLoadingMessage = function (dom) {
            let texts = ['Loading.', 'Loading..', 'Loading...'];
            let textIndex = 0;
            dom.loadingInterval = setInterval(() => {
                dom.innerText = texts[textIndex];
                textIndex += 1;
                if (textIndex === texts.length) {
                    textIndex = 0;
                }
            }, 400);
        }

        var collectEditedCounts = function () {
            let editedCounts = {}
            orderedImgNames.forEach((name, i) => {
                if (!eggLayingRegions[i] || eggLayingRegions[i].bad) {
                    return;
                }
                editedCounts[name] = {};
                Object.keys(eggLayingRegions[i]).forEach(region => {
                    if (eggLayingRegions[i][region].beenEdited()) {
                        editedCounts[name][eggLayingRegions[i][region].bboxIndex] =
                            eggLayingRegions[i][region].text.content;
                    }
                });
            });
            return editedCounts;
        }

        var setButtonHandlers = function () {
            document.getElementById('download-csv').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target);
                socket.emit('prepare-csv', {
                    time: Date.now(),
                    sid: sid,
                    editedCounts: collectEditedCounts()
                })
            }
            document.getElementById('download-imgs').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target)
                let requestTs = Date.now();
                socket.emit('prepare-annot-imgs-zip', {
                    time: requestTs,
                    sid: sid,
                    editedCounts: collectEditedCounts()
                });

            }
            document.getElementById('user-select').onchange = (evt) => {
                window.localStorage.setItem('user', evt.target.value);
            }
            document.getElementById('submit-error-report').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                if (document.getElementById('user-select').value === 'null') {
                    document.getElementById('user-select').style.borderColor = 'red';
                    document.getElementById('user-select').style.fontWeight = 'bold';
                    evt.target.innerText = 'Please set user first and try again.';
                    setTimeout(() => {
                        evt.target.innerText = 'Submit error report for all images';
                        evt.target.removeAttribute('disabled');
                        document.getElementById('user-select').style.borderColor = 'black';
                        document.getElementById('user-select').style.fontWeight = 'normal';
                    }, 2500);
                    return;
                }
                displayLoadingMessage(evt.target);
                socket.emit('submit-error-report', {
                    editedCounts: collectEditedCounts(),
                    sid: sid,
                    user: window.localStorage.getItem('user')
                });
            }
            if (orderedImgNames.length === 1) {
                document.getElementById('prev-img').setAttribute('disabled', true);
                document.getElementById('next-img').setAttribute('disabled', true);
                return
            }
            document.getElementById('prev-img').onclick = (evt) => {
                let newImgIdx = currentImgIndex - 1;
                if (newImgIdx >= 0) {
                    previousImgIndex = currentImgIndex;
                    currentImgIndex = newImgIdx;

                    redrawCanvas();
                    if (newImgIdx == 0) {
                        evt.target.setAttribute('disabled', true);
                    } else {
                        evt.target.removeAttribute('disabled');
                    }
                    document.getElementById('next-img').removeAttribute('disabled');
                }
            }
            document.getElementById('next-img').onclick = (evt) => {
                let newImgIdx = currentImgIndex + 1;
                if (newImgIdx <= orderedImgNames.length) {
                    previousImgIndex = currentImgIndex;
                    currentImgIndex = newImgIdx;
                    redrawCanvas();
                    if (evt.target.disabled) {
                        evt.target.removeAttribute('disabled');
                    }
                    if (newImgIdx > 0) {
                        document.getElementById('prev-img').removeAttribute('disabled');
                    }
                }
                if (newImgIdx >= orderedImgNames.length - 1) {
                    evt.target.setAttribute('disabled', true);
                    document.getElementById('prev-img').removeAttribute('disabled');
                }
            }
        }

        function base64ToBlob(base64, mime) {
            mime = mime || '';
            var sliceSize = 1024;
            var byteChars = window.atob(base64);
            var byteArrays = [];

            for (var offset = 0, len = byteChars.length; offset < len; offset += sliceSize) {
                var slice = byteChars.slice(offset, offset + sliceSize);

                var byteNumbers = new Array(slice.length);
                for (var i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                var byteArray = new Uint8Array(byteNumbers);

                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, { type: mime });
        }

        var redrawCanvas = function () {
            canvasLoaded = false;
            setCurrentImgName()
            if (backgroundRaster) {
                backgroundRaster.remove();
            }
            if (previousImgIndex !== null) {
                if (eggLayingRegions[previousImgIndex].bad) {
                    eggLayingRegions[previousImgIndex].text.remove();
                } else {
                    Object.keys(eggLayingRegions[previousImgIndex]).forEach(region => {
                        eggLayingRegions[previousImgIndex][region].text.remove();
                        eggLayingRegions[previousImgIndex][region].outline.remove();
                        eggLayingRegions[previousImgIndex][region].fill.remove();
                    });
                }
            }
            $('#updates').append(`<img id=pic src="/uploads/${orderedImgNames[currentImgIndex]}?lastmod=${Date.now()}">`);
            paper.project.clear();
            backgroundRaster = new paper.Raster('pic');
            pic = document.getElementById('pic');
            backgroundRaster.onLoad = () => {
                backgroundRaster.fitBounds(paper.view.viewSize);
                let scalingFactor = Math.min(canvasHeight / pic.height, canvasWidth / pic.width);
                document.getElementById('pic').remove();
                let upperPadding = 0.5 * (canvasHeight - backgroundRaster.bounds.height);
                let leftPadding = 0.5 * (canvasWidth - backgroundRaster.bounds.width);
                if ('error' in annotations[orderedImgNames[currentImgIndex]]) {
                    let pointText = new paper.PointText(new paper.Point(paper.view.center.x,
                        paper.view.center.y));
                    pointText.content = errorMessages[annotations[
                        orderedImgNames[currentImgIndex]].error];
                    pointText.justification = 'center';
                    pointText.fillColor = 'red';
                    pointText.fontSize = '40px';
                    eggLayingRegions[currentImgIndex] = { bad: true, text: pointText }
                } else {
                    if (!eggLayingRegions[currentImgIndex]) {
                        eggLayingRegions[currentImgIndex] = {};
                        annotations[orderedImgNames[currentImgIndex]].forEach((annotation, i) => {
                            let x = annotation.x * scalingFactor + leftPadding;
                            let y = annotation.y * scalingFactor + upperPadding;
                            let bbox = annotation.bbox;
                            bbox = bbox.map(n => n * scalingFactor);
                            let textOrigin = new paper.Point(x, y)
                            let pointText = new paper.PointText(new paper.Point(x, y));
                            pointText.justification = 'center';
                            pointText.fillColor = 'black';
                            pointText.content = annotation.count;
                            pointText.fontSize = defaultFontSize;
                            let rectangle = new paper.Rectangle(
                                new paper.Point(bbox[0] + leftPadding, bbox[1] + upperPadding),
                                new paper.Point(bbox[0] + bbox[2] + leftPadding, bbox[1] + bbox[3] + upperPadding));
                            rectPath = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                            rectPath.strokeColor = colors.grey;
                            let innerRect = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                            innerRect.fillColor = 'black';
                            innerRect.opacity = 0;
                            addHoverHandler(innerRect, currentImgIndex);
                            eggLayingRegions[currentImgIndex][innerRect.id] = {
                                outline: rectPath,
                                fill: innerRect,
                                text: pointText,
                                bboxIndex: i,
                                originalCount: annotation.count.toString(),
                                beenEdited() {
                                    return this.originalCount !== this.text.content;
                                }
                            };
                        });
                    } else {
                        Object.keys(eggLayingRegions[currentImgIndex]).forEach(region => {
                            // recreate the text
                            let reg = eggLayingRegions[currentImgIndex][region];
                            if (reg.beenEdited()) {
                                drawTextForEditedCount(reg, reg.text.content);
                            } else {
                                let origText = reg.text;
                                reg.text = new paper.PointText(new paper.Point(origText.point.x,
                                    origText.point.y));
                                reg.text.content = origText.content;
                                reg.text.justification = 'center';
                                reg.text.fillColor = reg.beenEdited() ? colors.red : 'black';
                                reg.text.fontSize = origText.fontSize;
                            }
                            // recreate the outline
                            let origOutline = reg.outline;
                            let rectangle = new paper.Rectangle(
                                new paper.Point(origOutline.bounds.x, origOutline.bounds.y),
                                new paper.Point(origOutline.bounds.x + origOutline.bounds.width,
                                    origOutline.bounds.y + origOutline.bounds.height)
                            );
                            reg.outline = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                            reg.outline.strokeColor = reg.beenEdited() ? colors.red : colors.grey;
                            // recreate the inner fill
                            let origFill = reg.fill;
                            reg.fill = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                            reg.fill.fillColor = 'black';
                            reg.fill.opacity = 0;
                            eggLayingRegions[currentImgIndex][reg.fill.id] = {
                                outline: reg.outline,
                                fill: reg.fill,
                                text: reg.text,
                                bboxIndex: reg.bboxIndex,
                                originalCount: reg.originalCount,
                                beenEdited() {
                                    return this.originalCount !== this.text.content;
                                }
                            }
                            delete eggLayingRegions[currentImgIndex][origFill.id];
                            addHoverHandler(reg.fill, currentImgIndex);
                        });
                    }
                }
                origCenter = paper.view.center;
                canvasLoaded = true;
            }
        }

        var drawTextForUneditedCount = (reg) => {
            if (reg.textPredicted) {
                reg.textPredicted.remove();
            }
            let x, y;
            if (reg.centeredTextPosition) {
                x = reg.centeredTextPosition.x;
                y = reg.centeredTextPosition.y
            } else {
                x = reg.text.point.x;
                y = reg.text.point.y;
            }
            reg.text.remove();
            reg.text = new paper.PointText(new paper.Point(x, y));
            reg.text.content = reg.originalCount;
            reg.text.justification = 'center';
            reg.text.fillColor = 'black';
            reg.text.fontSize = defaultFontSize;
        }

        var drawTextForEditedCount = (reg, value) => {
            if (!reg.centeredTextPosition) {
                reg.centeredTextPosition = reg.text.point;
            }
            let origText = reg.text;
            reg.text.remove();
            reg.text = new paper.PointText(new paper.Point(reg.centeredTextPosition.x, reg.centeredTextPosition.y - 10));
            reg.text.content = value;
            reg.text.justification = 'center';
            reg.text.fillColor = colors.red;
            reg.text.fontSize = origText.fontSize;
            if (reg.textPredicted) {
                reg.textPredicted.remove();
            }
            reg.textPredicted = new paper.PointText(new paper.Point(reg.centeredTextPosition.x, reg.centeredTextPosition.y + 10));
            reg.textPredicted.content = reg.originalCount;
            reg.textPredicted.justification = 'center';
            reg.textPredicted.fillColor = 'black';
            reg.textPredicted.fontSize = origText.fontSize;
        };

        var addHoverHandler = function (path, index) {
            path.onMouseEnter = () => {
                if (inputAmender) {
                    return;
                }
                if (eggLayingRegions[index][path.id].beenEdited()) {
                    eggLayingRegions[index][path.id].outline.strokeWidth = 2;
                    return;
                }
                eggLayingRegions[index][path.id].text.fillColor = colors.red;
                eggLayingRegions[index][path.id].outline.strokeColor = colors.red;
            }
            path.onMouseLeave = () => {
                if (inputAmender) {
                    return;
                }
                eggLayingRegions[index][path.id].outline.strokeWidth = 1;
                if (eggLayingRegions[index][path.id].beenEdited()) {
                    return;
                }
                eggLayingRegions[index][path.id].text.fillColor = 'black';
                eggLayingRegions[index][path.id].outline.strokeColor = colors.grey;
            }
            path.onClick = (event) => {
                if (inputAmender) {
                    return;
                }
                let viewer = document.getElementById('viewer')
                inputAmender = document.createElement('input');
                eggLayingRegions[index][path.id].text.opacity = 0;
                pathAmendId = path.id;
                inputAmender.type = 'text';
                inputAmender.setAttribute('class', 'live-count-editor');
                var viewportOffset = viewer.getBoundingClientRect();
                let text = eggLayingRegions[index][path.id].text;
                let fieldHeight = text.bounds.height * paper.view.zoom;
                let fieldWidth = text.bounds.width * paper.view.zoom;
                eggLayingRegions[index][path.id].outline.strokeWidth = 2;
                inputAmender.style = 'position: absolute; left:' +
                    ` ${viewer.offsetLeft + eggLayingRegions[index][path.id].outline.bounds.x}px; ` +
                    `top: ${viewer.offsetTop + eggLayingRegions[index][path.id].outline.bounds.y}px; ` +
                    `width: ${50 * paper.view.zoom}px;` +
                    `height: ${26 * paper.view.zoom}px;` +
                    `font-size: ${0.75 * text.fontSize * paper.view.zoom}px;`
                inputAmender.placeholder = 'e.g., 42';
                viewer.appendChild(inputAmender);
                inputAmender.focus();
                eggLayingRegions[index][path.id].text.fillColor = colors.red;
                eggLayingRegions[index][path.id].outline.strokeColor = colors.red;
                inputAmender.onkeydown = checkIfEnterKeyPressed
                inputAmender.oninput = amendEggCount;
            }
        }

        var checkIfEnterKeyPressed = function (event) {
            lastKeyPressed = event.code;
            if (!lastKeyPressed.startsWith('Digit') && !lastKeyPressed.startsWith('Key')) {
                amendEggCount(event, inputAmender.value);
            }
        }

        var amendEggCount = function (event, value = null) {
            if (lastKeyPressed === 'Escape') {
                let reg = eggLayingRegions[currentImgIndex][pathAmendId];
                reg.text.fillColor = reg.beenEdited() ? colors.red : 'black';
                reg.outline.strokeColor = reg.beenEdited() ? colors.red : colors.grey;
                reg.outline.strokeWidth = 1;
                reg.text.opacity = 1.0;
                inputAmender.remove();
                inputAmender = null;
                return;
            }
            let errorGrey = '#b99393';
            let okGrey = ' #acacac';
            if (!value) {
                value = this.value.toString()
            }
            if (lastKeyPressed === 'Enter') {
                if (isNormalInteger(value)) {
                    if (value == eggLayingRegions[currentImgIndex][pathAmendId].originalCount) {
                        idsWithEdits.delete(pathAmendId)
                        drawTextForUneditedCount(eggLayingRegions[currentImgIndex][pathAmendId]);
                    } else {
                        idsWithEdits.add(pathAmendId)
                        drawTextForEditedCount(eggLayingRegions[currentImgIndex][pathAmendId], value);
                    }
                    inputAmender.remove();
                    inputAmender = null;
                    if (idsWithEdits.size > 0) {
                        document.getElementById('submit-error-report').removeAttribute('hidden');
                    } else {
                        document.getElementById('submit-error-report').setAttribute('hidden', 'true');
                    }
                } else {
                    inputAmender.style.backgroundColor = errorGrey;
                }
            } else if (isNormalInteger(value)) {
                inputAmender.style.backgroundColor = okGrey;
            } else {
                inputAmender.style.backgroundColor = errorGrey;
            }
        }

        var setupCanvas = function () {
            let scalingFactor;
            $('#updates').append('<div id=viewer-nav></div>');
            $('#viewer-nav').append('<div id=button-row></div>')
            $('#button-row').append('<button class=nav-button id=reset-view>Reset view</button>');
            $('#button-row').append('<div class=divider></div>');
            $('#button-row').append('<button class=nav-button disabled id=prev-img>Previous image</button>');
            $('#button-row').append('<div class=divider></div>');
            $('#button-row').append('<button class=nav-button id=next-img>Next image</button>');
            $('#button-row').append('<div class=divider></div>');
            $('#button-row').append('<button id=download-imgs>Download annotated images</button>');
            $('#button-row').append('<div class=divider></div>');
            $('#button-row').append('<button hidden id=submit-error-report>Submit error report for all images</button>');
            $('#button-row').append('<div class=divider></div>');
            $('#button-row').append('<select id=user-select></select><br>');
            let selector = document.getElementById('user-select');
            let opt;
            opt = document.createElement('option');
            opt.value = null;
            opt.innerText = 'User: not set';
            selector.append(opt);
            {% for user in users %}
            opt = document.createElement('option');
            opt.value = '{{user}}'
            opt.innerText = 'User: {{user}}'
            selector.appendChild(opt);
            {% endfor %}
            if (window.localStorage.getItem('user')) {
                selector.value = window.localStorage.getItem('user');
            }
            $('#viewer-nav').append('<div class=divider></div>');
            $('#updates').append('<br><div id=current-img-parent><p id=current-img></p>');
            setCurrentImgName()
            setButtonHandlers()
            $('#reset-view').click(reposition)
            $('#updates').append('<div id=viewer></div>')
            $('#viewer').append('<canvas keepalive=true id=detectionResults></canvas>');
            canvas = document.getElementById('detectionResults');
            paper.install(window);
            paper.setup(canvas);
            paper.view.viewSize = new paper.Size(canvasWidth, canvasHeight);
            redrawCanvas();
            setPointerHandlers();
            setDragHandler();
        }

        var zoomInAndOut = e => {
            if (!e.shiftKey || inputAmender) {
                return;
            }
            e.preventDefault();
            if (lastScrollTime && Date.now() - lastScrollTime < 250) {
                return;
            }
            lastScrollTime = Date.now();
            let view = paper.view;
            let viewPosition = view.viewToProject(
                new paper.Point(e.offsetX, e.offsetY)
            );

            let transform = changeZoom(e.deltaY, viewPosition);
            if (paper.view.zoom <= 1 && transform.zoom <= 1) {
                return;
            }
            if (transform.zoom < 10 && transform.zoom > 0.01) {
                newScale = 1 / transform.zoom;
                paper.view.zoom = transform.zoom;
                paper.view.center = view.center.add(transform.offset);
            }
        }

        var changeZoom = (delta, p) => {
            let oldZoom = paper.view.zoom;
            let c = paper.view.center;
            let factor = 1 + zoom;

            let zoomTemp = delta < 0 ? oldZoom * factor : oldZoom / factor;
            let beta = oldZoom / zoomTemp;
            let pc = p.subtract(c);
            let a = p.subtract(pc.multiply(beta)).subtract(c);

            return { zoom: zoomTemp, offset: a };
        }

        var setPointerHandlers = function () {
            canvas.addEventListener('wheel', zoomInAndOut, { passive: false });
            paper.view.on('mousedown', function () {
                pointerDown = true;
                timeDownUp = new Date().getTime();
                dragStart = true;
            });
            paper.view.on('mouseup', function () {
                pointerDown = false;
                timeDownUp = new Date().getTime();
                dragStart = false;
            });
        }

        var setDragHandler = () => {
            var toolPan = new paper.Tool();
            toolPan.onMouseDrag = function (evt) {
                if (inputAmender) {
                    return;
                }
                var timeMove = new Date().getTime();
                if (timeMove > timeDownUp) {
                    if (dragStart) {
                        var offset = new paper.Point(evt.downPoint.x - evt.point.x,
                            evt.downPoint.y - evt.point.y);
                        let new_center = paper.view.center.add(offset);
                        paper.view.setCenter(new_center);
                    }
                } else {
                    timeDownUp = null;
                }
            };
        }

        function reposition() {
            paper.view.zoom = 1;
            paper.view.center = origCenter;
            dragStart = false;
        }
    </script>

    <div class="modal" id="modal-1" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div id='egg-flagger-div' role="dialog" aria-modal="true" aria-labelledby="modal-1-title">
                <header>
                    <h2 id="modal-1-title">
                        Session expired
                    </h2>
                    <div style="display: none;" hidden id="close-button">
                        <div class="close-button-stroke1">
                            <div class="close-button-stroke2"></div>
                        </div>
                    </div>
                    <button id=close-modal hidden aria-label="Close modal" data-micromodal-close></button>
                </header>
                <div id="egg-flagger-dialog">
                    <p>The connection to the server has been lost; please refresh the page to continue.</p>
                </div>
            </div>
        </div>
    </div>
    <div id="page-mask"></div>
    <script>
        MicroModal.init();
        document.getElementById('close-button').onclick = () => {
            document.getElementById('close-modal').click();
        };
    </script>
</body>