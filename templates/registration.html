<!doctype html>

<head>
    <script src="https://cdn.socket.io/socket.io-3.0.1.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.7/paper-full.js"></script>
    <script src="../static/js/micromodal.min.js"></script>
    <title>Egg Counting</title>
</head>

<body>
    <script type="text/javascript">
        const socket = io();
        const colors = {
            grey: '#313036',
            red: '#fc2c03'
        };
        const defaultFontSize = 17;
        let sid;
        let input, inputs, inputDiv, inputLbl, inputReset, preview;
        let inputAmender;
        let inputAmenderNormalBckgnd;
        let lastKeyPressed;
        let pathAmendId;
        let annotations = {};
        let orderedImgNames = [];
        let eggLayingRegions = [];
        let loadingInterval;
        let zoom = 1.0;
        let idsWithEdits = new Set();
        let lastScrollTime;
        let canvas;
        let canvasLoaded = false;
        let canvasWidth = Math.min(1300, window.innerWidth),
            canvasHeight = Math.min(800, window.innerHeight);
        let pointerDown = false;
        let dragStart = false;
        let timeDownUp;
        let origCenter;
        let currentImgIndex = 0;
        let previousImgIndex;
        let backgroundRaster, pic;

        function isNormalInteger(str) {
            var n = Math.floor(Number(str));
            return n !== Infinity && String(n) === str && n >= 0;
        }
    </script>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/main.css') }}">
    <label for="img-upload-1">Upload one or more egg-counting images<br>
        <span style="font-size: small; padding-left: 15px;">
            Note: hold down Ctrl key to select multiple files.
        </span>
    </label>
    <form id=img-form method=post enctype="multipart/form-data">
        <div id=img-inputs>
            <label id="img-upload-lbl" for="img-upload-1">Choose images to upload</label>
            <button hidden id=img-upload-reset type="button">Reset</button>
            <input class=img-upload type=file multiple="multiple" id="img-upload-1" name="img-upload-1">
        </div>
        <div class="preview">
            <p>No files currently selected for upload.</p>
        </div>
        <div>
            <button id='img-upload-btn' type=button>Upload</button>
        </div>
    </form>
    <div id=updates></div>
    <button id="modalToggle" hidden data-micromodal-trigger="modal-1"></button>
    <script type="text/javascript">
        const fileTypes = [
            "image/apng",
            "image/bmp",
            "image/gif",
            "image/jpeg",
            "image/pjpeg",
            "image/png",
            "image/svg+xml",
            "image/tiff",
            "image/webp",
            "image/x-icon"
        ];

        function validFileType(file) {
            return fileTypes.includes(file.type);
        }

        $(function () {
            $('#img-upload-btn').click(function () {
                $(this).prop('disabled', true);
                var form_data = new FormData($('#img-form')[0]);
                form_data.append('sid', sid);
                $.ajax({
                    type: 'POST',
                    url: '/upload',
                    data: form_data,
                    contentType: false,
                    cache: false,
                    processData: false,
                    success: function (data) {
                        console.log('Success!');
                    },
                });
            });
        });

        $(document).ready(() => {
            socket.on('counting-progress', (msg) => {
                $('#updates').append('<p>' + msg.data + '</p>')
            });
            socket.on('counting-done', () => {
                $('#updates').append('<div><button type=button id=download-csv>Download results</button></div>')
                $('#updates').append('<div class=divider style="height: 2px;"></div>');
                setupCanvas();
                document.getElementById('img-upload-btn').removeAttribute('disabled');
            });
            socket.on('counting-csv', (msg) => {
                $('#updates').append(`<form id=csv-retrieve hidden action=/csvResults/${msg.data}><input hidden value='Download results' type=submit>` +
                    '</input></form>');
                document.getElementById('csv-retrieve').submit();
                document.getElementById('csv-retrieve').remove();
                document.getElementById('download-csv').removeAttribute('disabled');
                clearInterval(document.getElementById('download-csv').loadingInterval);
            });
            socket.on('counting-annotations', (msg) => {
                annotations[msg.filename] = JSON.parse(msg.data);
                orderedImgNames.push(msg.filename);
            });
            socket.on('clear-all', () => {
                if (!!document.getElementById('updates')) {
                    $('#updates').empty();
                }
                annotations = {};
                orderedImgNames = [];
            });
            socket.on('clear-display', () => {
                $('#updates').empty();
            });
            socket.on('report-ready', () => {
                let el = document.getElementById('submit-error-report')
                el.removeAttribute('disabled');
                el.innerText = 'Submitted!';
                setTimeout(() => {
                    el.innerText = 'Submit error report for all images';
                }, 2500)
                clearInterval(el.loadingInterval);
            });
            socket.on('zip-annots-ready', (msg) => {
                $('#updates').append(`<form hidden id=annot-retrieve action=/annot-img/${msg.time}><input id=annot-retrieve-input hidden id= value='Download results' type=submit>` +
                    '</input></form>')
                document.getElementById('annot-retrieve').submit();
                document.getElementById('annot-retrieve').remove();
                document.getElementById('download-imgs').innerText = 'Download annotated images';
                document.getElementById('download-imgs').removeAttribute('disabled');
                clearInterval(document.getElementById('download-imgs').loadingInterval)
            });
            socket.on('sid-from-server', (msg) => {
                sid = msg.sid;
            });
            setUpFileUploadDialog();
        });

        var setUpFileUploadDialog = function () {
            input = document.getElementById('img-upload-1');
            inputs = [input]
            inputLbl = document.getElementById('img-upload-lbl');
            inputDiv = document.getElementById('img-inputs');
            inputReset = document.getElementById('img-upload-reset')
            preview = document.querySelector('.preview');
            input.addEventListener('change', updateImageDisplay);
            inputReset.onclick = handleResetClick;
        }

        var handleResetClick = function () {
            inputs[0].value = "";
            inputs.forEach((input, i) => {
                if (i > 0) {
                    input.remove();
                }
            });
            inputs = inputs.slice(0, 1);
            input = inputs[0];
            input.addEventListener('change', updateImageDisplay);
            updateImageDisplay(false);
            inputReset.setAttribute('hidden', true);
            inputLbl.setAttribute('for', input.id);
            inputLbl.innerText = 'Choose images to upload';
        };

        var addNewImageInput = () => {
            let newInput = document.createElement('input');
            newInput.type = 'file';
            newInput.multiple = 'multiple';
            let newInputIdAndName = `img-upload-${document.getElementsByClassName('img-upload').length + 1}`;
            newInput.id = newInputIdAndName;
            newInput.name = newInputIdAndName;
            newInput.setAttribute('class', 'img-upload');
            newInput.setAttribute('hidden', 'true');
            inputDiv.appendChild(newInput);
            inputs.push(newInput);
            input.removeEventListener('change', updateImageDisplay);
            input = newInput;
            input.addEventListener('change', updateImageDisplay);
            inputLbl.setAttribute('for', newInputIdAndName);

        }

        function updateImageDisplay(addNewInput = true) {
            if (addNewInput) {
                addNewImageInput();
            }
            while (preview.firstChild) {
                preview.removeChild(preview.firstChild);
            }
            inputLbl.innerText = "Select more images";
            inputReset.removeAttribute('hidden');
            let curFiles = [];
            inputs.forEach(i => {
                curFiles = Array.from(curFiles).concat(Array.from(i.files));
            })
            if (curFiles.length === 0) {
                const para = document.createElement('p');
                para.textContent = 'No files currently selected for upload';
                preview.appendChild(para);
            } else {
                const list = document.createElement('ol');
                preview.appendChild(list);

                for (const file of curFiles) {
                    const listItem = document.createElement('li');
                    const para = document.createElement('p');
                    if (validFileType(file)) {
                        para.textContent = `File name ${file.name}, file size ${returnFileSize(file.size)}.`;
                        const image = document.createElement('img');
                        image.src = URL.createObjectURL(file);

                        listItem.appendChild(image);
                        listItem.appendChild(para);
                    } else {
                        para.textContent = `File name ${file.name}: Not a valid file type. Update your selection.`;
                        listItem.appendChild(para);
                    }

                    list.appendChild(listItem);
                }
            }
        }

        function returnFileSize(number) {
            if (number < 1024) {
                return number + 'bytes';
            } else if (number >= 1024 && number < 1048576) {
                return (number / 1024).toFixed(1) + 'KB';
            } else if (number >= 1048576) {
                return (number / 1048576).toFixed(1) + 'MB';
            }
        }

        var setCurrentImgName = function () {
            document.getElementById('current-img').innerText =
                `Viewing image ${orderedImgNames[currentImgIndex]} (Shift + scroll to zoom)`;
        }

        var appendToFilename = function (filename, addition) {
            return filename.replace(/(\.[\w\d_-]+)$/i, `${addition}$1`)
        }

        var displayLoadingMessage = function (dom) {
            let texts = ['Loading.', 'Loading..', 'Loading...'];
            let textIndex = 0;
            dom.loadingInterval = setInterval(() => {
                dom.innerText = texts[textIndex];
                textIndex += 1;
                if (textIndex === texts.length) {
                    textIndex = 0;
                }
            }, 400);
        }

        var collectEditedCounts = function () {
            let editedCounts = {}
            orderedImgNames.forEach((name, i) => {
                if (!eggLayingRegions[i]) {
                    return;
                }
                editedCounts[name] = {};
                Object.keys(eggLayingRegions[i]).forEach(region => {
                    if (eggLayingRegions[i][region].beenEdited()) {
                        editedCounts[name][eggLayingRegions[i][region].bboxIndex] =
                            eggLayingRegions[i][region].text.content;
                    }
                });
            });
            return editedCounts;
        }

        var setButtonHandlers = function () {
            document.getElementById('download-csv').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target);
                socket.emit('prepare-csv', {
                    time: Date.now(),
                    sid: sid,
                    editedCounts: collectEditedCounts()
                })
            }
            document.getElementById('download-imgs').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target)
                let requestTs = Date.now();
                socket.emit('prepare-annot-imgs-zip', {
                    time: requestTs,
                    sid: sid,
                    editedCounts: collectEditedCounts()
                });

            }
            document.getElementById('submit-error-report').onclick = (evt) => {
                evt.target.setAttribute('disabled', 'true');
                displayLoadingMessage(evt.target);
                socket.emit('submit-error-report', {
                    editedCounts: collectEditedCounts(),
                    sid: sid
                });
            }
            if (orderedImgNames.length === 1) {
                document.getElementById('prev-img').setAttribute('disabled', true);
                document.getElementById('next-img').setAttribute('disabled', true);
                return
            }
            document.getElementById('prev-img').onclick = (evt) => {
                let newImgIdx = currentImgIndex - 1;
                if (newImgIdx >= 0) {
                    previousImgIndex = currentImgIndex;
                    currentImgIndex = newImgIdx;

                    redrawCanvas();
                    if (newImgIdx == 0) {
                        evt.target.setAttribute('disabled', true);
                        document.getElementById('next-img').removeAttribute('disabled');
                    } else {
                        evt.target.removeAttribute('disabled');
                    }
                }
            }
            document.getElementById('next-img').onclick = (evt) => {
                let newImgIdx = currentImgIndex + 1;
                if (newImgIdx <= orderedImgNames.length) {
                    previousImgIndex = currentImgIndex;
                    currentImgIndex = newImgIdx;
                    redrawCanvas();
                    if (evt.target.disabled) {
                        evt.target.removeAttribute('disabled');
                    }
                    if (newImgIdx > 0) {
                        document.getElementById('prev-img').removeAttribute('disabled');
                    }
                }
                if (newImgIdx >= orderedImgNames.length - 1) {
                    evt.target.setAttribute('disabled', true);
                    document.getElementById('prev-img').removeAttribute('disabled');
                }
            }
        }

        function base64ToBlob(base64, mime) {
            mime = mime || '';
            var sliceSize = 1024;
            var byteChars = window.atob(base64);
            var byteArrays = [];

            for (var offset = 0, len = byteChars.length; offset < len; offset += sliceSize) {
                var slice = byteChars.slice(offset, offset + sliceSize);

                var byteNumbers = new Array(slice.length);
                for (var i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                var byteArray = new Uint8Array(byteNumbers);

                byteArrays.push(byteArray);
            }

            return new Blob(byteArrays, { type: mime });
        }

        var redrawCanvas = function () {
            canvasLoaded = false;
            setCurrentImgName()
            if (backgroundRaster) {
                backgroundRaster.remove();
            }
            paper.project.clear();
            if (previousImgIndex) {
                Object.keys(eggLayingRegions[previousImgIndex]).forEach(region => {
                    eggLayingRegions[previousImgIndex][region].outline.remove();
                    eggLayingRegions[previousImgIndex][region].fill.remove();
                    eggLayingRegions[previousImgIndex][region].text.remove();
                })
            }
            $('#updates').append(`<img id=pic src="/uploads/${orderedImgNames[currentImgIndex]}">`);
            backgroundRaster = new paper.Raster('pic');
            pic = document.getElementById('pic');
            backgroundRaster.onLoad = () => {
                backgroundRaster.fitBounds(paper.view.viewSize);
                let scalingFactor = Math.min(canvasHeight / pic.height, canvasWidth / pic.width);
                document.getElementById('pic').remove();
                let upperPadding = 0.5 * (canvasHeight - backgroundRaster.bounds.height);
                let leftPadding = 0.5 * (canvasWidth - backgroundRaster.bounds.width);
                if (!eggLayingRegions[currentImgIndex]) {
                    eggLayingRegions[currentImgIndex] = {};
                    annotations[orderedImgNames[currentImgIndex]].forEach((annotation, i) => {
                        let x = annotation.x * scalingFactor + leftPadding;
                        let y = annotation.y * scalingFactor + upperPadding;
                        let bbox = annotation.bbox;
                        bbox = bbox.map(n => n * scalingFactor);
                        let textOrigin = new paper.Point(x, y)
                        let pointText = new paper.PointText(new paper.Point(x, y));
                        pointText.justification = 'center';
                        pointText.fillColor = 'black';
                        pointText.content = annotation.count;
                        pointText.fontSize = defaultFontSize;
                        let rectangle = new paper.Rectangle(
                            new paper.Point(bbox[0] + leftPadding, bbox[1] + upperPadding),
                            new paper.Point(bbox[0] + bbox[2] + leftPadding, bbox[1] + bbox[3] + upperPadding));
                        rectPath = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                        rectPath.strokeColor = colors.grey;
                        let innerRect = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                        innerRect.fillColor = 'black';
                        innerRect.opacity = 0;
                        addHoverHandler(innerRect, currentImgIndex);
                        eggLayingRegions[currentImgIndex][innerRect.id] = {
                            outline: rectPath,
                            fill: innerRect,
                            text: pointText,
                            bboxIndex: i,
                            originalCount: annotation.count.toString(),
                            beenEdited() {
                                return this.originalCount !== this.text.content;
                            }
                        };
                    });
                } else {
                    Object.keys(eggLayingRegions[currentImgIndex]).forEach(region => {
                        // recreate the text
                        let reg = eggLayingRegions[currentImgIndex][region];
                        if (reg.beenEdited()) {
                            drawTextForEditedCount(reg, reg.text.content);
                        } else {
                            let origText = reg.text;
                            reg.text = new paper.PointText(new paper.Point(origText.point.x,
                                origText.point.y));
                            reg.text.content = origText.content;
                            reg.text.justification = 'center';
                            reg.text.fillColor = reg.beenEdited() ? colors.red : 'black';
                            reg.text.fontSize = origText.fontSize;
                        }
                        // recreate the outline
                        let origOutline = reg.outline;
                        let rectangle = new paper.Rectangle(
                            new paper.Point(origOutline.bounds.x, origOutline.bounds.y),
                            new paper.Point(origOutline.bounds.x + origOutline.bounds.width,
                                origOutline.bounds.y + origOutline.bounds.height)
                        );
                        reg.outline = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                        reg.outline.strokeColor = reg.beenEdited() ? colors.red : colors.grey;
                        // recreate the inner fill
                        let origFill = reg.fill;
                        reg.fill = new paper.Path.Rectangle(rectangle, new paper.Size(2, 2));
                        reg.fill.fillColor = 'black';
                        reg.fill.opacity = 0;
                        eggLayingRegions[currentImgIndex][reg.fill.id] = {
                            outline: reg.outline,
                            fill: reg.fill,
                            text: reg.text,
                            bboxIndex: reg.bboxIndex,
                            originalCount: reg.originalCount,
                            beenEdited() {
                                return this.originalCount !== this.text.content;
                            }
                        }
                        delete eggLayingRegions[currentImgIndex][origFill.id];
                        addHoverHandler(reg.fill, currentImgIndex);
                    });
                }
                origCenter = paper.view.center;
                canvasLoaded = true;
            }
        }

        var drawTextForUneditedCount = (reg) => {
            if (reg.textPredicted) {
                reg.textPredicted.remove();
            }
            let x, y;
            if (reg.centeredTextPosition) {
                x = reg.centeredTextPosition.x;
                y = reg.centeredTextPosition.y
            } else {
                x = reg.text.point.x;
                y = reg.text.point.y;
            }
            reg.text.remove();
            reg.text = new paper.PointText(new paper.Point(x, y));
            reg.text.content = reg.originalCount;
            reg.text.justification = 'center';
            reg.text.fillColor = 'black';
            reg.text.fontSize = defaultFontSize;
        }

        var drawTextForEditedCount = (reg, value) => {
            if (!reg.centeredTextPosition) {
                reg.centeredTextPosition = reg.text.point;
            }
            let origText = reg.text;
            reg.text.remove();
            reg.text = new paper.PointText(new paper.Point(reg.centeredTextPosition.x, reg.centeredTextPosition.y - 10));
            reg.text.content = value;
            reg.text.justification = 'center';
            reg.text.fillColor = colors.red;
            reg.text.fontSize = origText.fontSize;
            if (reg.textPredicted) {
                reg.textPredicted.remove();
            }
            reg.textPredicted = new paper.PointText(new paper.Point(reg.centeredTextPosition.x, reg.centeredTextPosition.y + 10));
            reg.textPredicted.content = reg.originalCount;
            reg.textPredicted.justification = 'center';
            reg.textPredicted.fillColor = 'black';
            reg.textPredicted.fontSize = origText.fontSize;
        };

        var addHoverHandler = function (path, index) {
            path.onMouseEnter = () => {
                if (inputAmender) {
                    return;
                }
                if (eggLayingRegions[index][path.id].beenEdited()) {
                    eggLayingRegions[index][path.id].outline.strokeWidth = 2;
                    return;
                }
                eggLayingRegions[index][path.id].text.fillColor = colors.red;
                eggLayingRegions[index][path.id].outline.strokeColor = colors.red;
            }
            path.onMouseLeave = () => {
                if (inputAmender) {
                    return;
                }
                eggLayingRegions[index][path.id].outline.strokeWidth = 1;
                if (eggLayingRegions[index][path.id].beenEdited()) {
                    return;
                }
                eggLayingRegions[index][path.id].text.fillColor = 'black';
                eggLayingRegions[index][path.id].outline.strokeColor = colors.grey;
            }
            path.onClick = (event) => {
                if (inputAmender) {
                    return;
                }
                let viewer = document.getElementById('viewer')
                inputAmender = document.createElement('input');
                eggLayingRegions[index][path.id].text.opacity = 0;
                pathAmendId = path.id;
                inputAmender.type = 'text';
                inputAmender.setAttribute('class', 'live-count-editor');
                var viewportOffset = viewer.getBoundingClientRect();
                let text = eggLayingRegions[index][path.id].text;
                let fieldHeight = text.bounds.height * paper.view.zoom;
                let fieldWidth = text.bounds.width * paper.view.zoom;
                eggLayingRegions[index][path.id].outline.strokeWidth = 2;
                inputAmender.style = 'position: absolute; left:' +
                    ` ${viewer.offsetLeft + eggLayingRegions[index][path.id].outline.bounds.x}px; ` +
                    `top: ${viewer.offsetTop + eggLayingRegions[index][path.id].outline.bounds.y}px; ` +
                    `width: ${50 * paper.view.zoom}px;` +
                    `height: ${26 * paper.view.zoom}px;` +
                    `font-size: ${0.75 * text.fontSize * paper.view.zoom}px;`
                inputAmender.placeholder = 'e.g., 42';
                viewer.appendChild(inputAmender);
                inputAmender.focus();
                eggLayingRegions[index][path.id].text.fillColor = colors.red;
                eggLayingRegions[index][path.id].outline.strokeColor = colors.red;
                inputAmender.onkeydown = checkIfEnterKeyPressed
                inputAmender.oninput = amendEggCount;
            }
        }

        var checkIfEnterKeyPressed = function (event) {
            lastKeyPressed = event.code;
            if (!lastKeyPressed.startsWith('Digit') && !lastKeyPressed.startsWith('Key')) {
                amendEggCount(event, inputAmender.value);
            }
        }

        var amendEggCount = function (event, value = null) {
            // how to represent whether any counts have been amended
            // throughout all uploaded images?
            // ideally, it won't be necessary to recalculate anything.
            // there should be a v
            if (lastKeyPressed === 'Escape') {
                let reg = eggLayingRegions[currentImgIndex][pathAmendId];
                reg.text.fillColor = reg.beenEdited() ? colors.red : 'black';
                reg.outline.strokeColor = reg.beenEdited() ? colors.red : colors.grey;
                reg.outline.strokeWidth = 1;
                reg.text.opacity = 1.0;
                inputAmender.remove();
                inputAmender = null;
                return;
            }
            let errorGrey = '#b99393';
            let okGrey = ' #acacac';
            if (!value) {
                value = this.value.toString()
            }
            if (lastKeyPressed === 'Enter') {
                if (isNormalInteger(value)) {
                    // how best to draw both
                    // vertically aligned in a way that it can be put back if reverted?
                    // save the positions of the original pointText?
                    // when to add to idsWithEdits
                    if (value == eggLayingRegions[currentImgIndex][pathAmendId].originalCount) {
                        idsWithEdits.delete(pathAmendId)
                        drawTextForUneditedCount(eggLayingRegions[currentImgIndex][pathAmendId]);
                    } else {
                        idsWithEdits.add(pathAmendId)
                        drawTextForEditedCount(eggLayingRegions[currentImgIndex][pathAmendId], value);
                    }
                    // eggLayingRegions[currentImgIndex][pathAmendId].text.content = value;
                    // eggLayingRegions[currentImgIndex][pathAmendId].text.opacity = 1.0;
                    // eggLayingRegions[currentImgIndex][pathAmendId].outline.strokeWidth = 1;
                    inputAmender.remove();
                    inputAmender = null;
                    if (idsWithEdits.size > 0) {
                        document.getElementById('submit-error-report').removeAttribute('hidden');
                    } else {
                        document.getElementById('submit-error-report').setAttribute('hidden', 'true');
                    }
                } else {
                    inputAmender.style.backgroundColor = errorGrey;
                }
            } else if (isNormalInteger(value)) {
                inputAmender.style.backgroundColor = okGrey;
            } else {
                inputAmender.style.backgroundColor = errorGrey;
            }
        }

        var setupCanvas = function () {
            let scalingFactor;
            $('#updates').append('<div id=viewer-nav></div>')
            $('#viewer-nav').append('<button class=nav-button id=reset-view>Reset view</button>');
            $('#viewer-nav').append('<div class=divider></div>');
            $('#viewer-nav').append('<button class=nav-button disabled id=prev-img>Previous image</button>');
            $('#viewer-nav').append('<div class=divider></div>');
            $('#viewer-nav').append('<button class=nav-button id=next-img>Next image</button>');
            $('#viewer-nav').append('<div class=divider></div>');
            $('#viewer-nav').append('<button id=download-imgs>Download annotated images</button>');
            $('#viewer-nav').append('<div class=divider></div>');
            $('#viewer-nav').append('<button hidden id=submit-error-report>Submit error report for all images</button><br>');
            $('#viewer-nav').append('<div class=divider></div>');
            $('#viewer-nav').append('<p id=current-img></p>');
            setCurrentImgName()
            setButtonHandlers()
            $('#reset-view').click(reposition)
            $('#updates').append('<div id=viewer></div>')
            $('#viewer').append('<canvas keepalive=true id=detectionResults></canvas>');
            canvas = document.getElementById('detectionResults');
            paper.install(window);
            paper.setup(canvas);
            paper.view.viewSize = new paper.Size(canvasWidth, canvasHeight);
            redrawCanvas();
            setPointerHandlers();
            setDragHandler();
        }

        var zoomInAndOut = e => {
            if (!e.shiftKey || inputAmender) {
                return;
            }
            e.preventDefault();
            if (lastScrollTime && Date.now() - lastScrollTime < 250) {
                return;
            }
            lastScrollTime = Date.now();
            let view = paper.view;
            let viewPosition = view.viewToProject(
                new paper.Point(e.offsetX, e.offsetY)
            );

            let transform = changeZoom(e.deltaY, viewPosition);
            if (paper.view.zoom <= 1 && transform.zoom <= 1) {
                return;
            }
            if (transform.zoom < 10 && transform.zoom > 0.01) {
                newScale = 1 / transform.zoom;
                paper.view.zoom = transform.zoom;
                paper.view.center = view.center.add(transform.offset);
            }
        }

        var changeZoom = (delta, p) => {
            let oldZoom = paper.view.zoom;
            let c = paper.view.center;
            let factor = 1 + zoom;

            let zoomTemp = delta < 0 ? oldZoom * factor : oldZoom / factor;
            let beta = oldZoom / zoomTemp;
            let pc = p.subtract(c);
            let a = p.subtract(pc.multiply(beta)).subtract(c);

            return { zoom: zoomTemp, offset: a };
        }

        var setPointerHandlers = function () {
            canvas.addEventListener('wheel', zoomInAndOut, { passive: false });
            paper.view.on('mousedown', function () {
                pointerDown = true;
                timeDownUp = new Date().getTime();
                dragStart = true;
            });
            paper.view.on('mouseup', function () {
                pointerDown = false;
                timeDownUp = new Date().getTime();
                dragStart = false;
            });
        }

        var setDragHandler = () => {
            var toolPan = new paper.Tool();
            toolPan.onMouseDrag = function (evt) {
                if (inputAmender) {
                    return;
                }
                var timeMove = new Date().getTime();
                if (timeMove > timeDownUp) {
                    if (dragStart) {
                        var offset = new paper.Point(evt.downPoint.x - evt.point.x,
                            evt.downPoint.y - evt.point.y);
                        let new_center = paper.view.center.add(offset);
                        paper.view.setCenter(new_center);
                    }
                } else {
                    timeDownUp = null;
                }
            };
        }

        function reposition() {
            paper.view.zoom = 1;
            paper.view.center = origCenter;
            dragStart = false;
        }
    </script>

    <div class="modal" id="modal-1" aria-hidden="true">
        <div tabindex="-1" data-micromodal-close>
            <div id='egg-flagger-div' role="dialog" aria-modal="true" aria-labelledby="modal-1-title">
                <header>
                    <h2 id="modal-1-title">
                        Submit error report
                    </h2>
                    <div id="close-button">
                        <div class="close-button-stroke1">
                            <div class="close-button-stroke2"></div>
                        </div>
                    </div>
                    <button id=close-modal hidden aria-label="Close modal" data-micromodal-close></button>
                </header>
                <div id="egg-flagger-dialog">
                    <form>
                        <button id=add-numeric-input type="button">I want to submit both the image and my estimate of
                            the egg count</button>
                        <button id=skip-numeric-input type="button">I want to submit the image only, <strong>no</strong>
                            estimate.</button>
                        <button id=flagged-img-toggle type="button">Show flagged image</button>
                    </form>
                    <div hidden id=egg-count-editor>
                        <form>
                            <label for="flagged-img-egg-count">My egg count:</label>
                            <input id=flagged-img-egg-count type="text" placeholder="e.g., 42">
                            <button disabled type="button" id="submit-error-with-count">Submit</button>
                        </form>
                    </div>
                    <div id=embedded-img></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        MicroModal.init();
        document.getElementById('close-button').onclick = () => {
            document.getElementById('close-modal').click();
        };
        document.getElementById('add-numeric-input').onclick = () => {
            let editorDiv = document.getElementById('egg-count-editor');
            if (editorDiv.hasAttribute('hidden')) {
                editorDiv.removeAttribute('hidden')
            } else {
                editorDiv.setAttribute('hidden', 'true');
            }
        };
        let eggCountTextField = document.getElementById('flagged-img-egg-count');
        let eggCountSubmitButton = document.getElementById('submit-error-with-count');
        eggCountTextField.onkeypress = () => {
            if (isNormalInteger(eggCountTextField.value)) {
                eggCountSubmitButton.removeAttribute('disabled');
            } else {
                eggCountSubmitButton.setAttribute('disabled', 'true');
            }
        }
    </script>
</body>